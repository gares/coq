
Example:
       move => + /invert /[ x y H | + H1 H2 | *- | toto_^- | -^1 ]
       move => [ ^toto | .. ]
       =>  [H1|H2]
       =>  /invert /[H1|H2]    
       =>  /invert [H1|H2]   
       =>  /eqP H - H2
       case: H => x1 x2 - H

  C : forall n (H: P n), Q (S n)
   
   toto_n
   toto_H

  R := { foo : _; bar : _ }
    toto_foo
    toto_bar

Alternative to marks:

   general mechanism for tracing the source of hypotheses

   => ARTHUR et ENRICO vont regarder les cas d'utilisation pratique


Alternative to +:  => ARTHUR va regarder

   >   enters fast introduction mode: only non-dependent 
       variables are considered by the following intropatterns
       (remark: fast mode does not change the semantics of * and *-).

   <   goes back to slow introduction mode: all variables are 
   

   Note that ">" and "<" and "/" and "[" and "]" act as separators 
   and need not be separated by spaces. In particular, this allows 
   to write "move =>> H".

   Note that the "fast/slow" mode does distribute inside the bracket:
   we go back to slow mode inside the bracket. However, it is not hard 
   to re-enter fast mode in the brackets on a per-need basis, e.g.:
       move =>> ~invert ~[x y H | > H1 H2]
         
-----------------------------



Another solution is to say that chaining is not such a great
idea anyway, especially when side-conditions are produced.
One could write scripts like:


      rewrite E. rewrite F.
 or   rew E. rew F.
 or   -> E. -> F.

Consider realistic examples before complaining.

       rewrite subsetI ucn_sub // -commg_subr.
  vs   rew subsetI //. rew ucn_sub //. rew -commg_subr.
  vs   ->subsetI //. ->ucn_sub //. <-commg_subr.
   
       rewrite leq_divRL // divn_mulAC leq_divLR dvdn_mulr dvdn_lcmr //.
  vs   -> leq_divRL // divn_mulAC leq_divLR dvdn_mulr dvdn_lcmr //.
  vs   ->leq_divRL//. ->divn_mulAC. ->leq_divLR//. ->dvdn_mulr. ->dvdn_lcmr//.
  vs   ->leq_divRL//. ->divn_mulAC. ->leq_divLR//. ->dvdn_mulr. ->dvdn_lcmr//.

=> H H1 -> H2.

Remark: for stepping through the "main" steps of a proof, you could either
have a shortcut for executing scripts line by line, or for a finer-grained
mechanism, you could use brackets, and have a shortcut for stepping at once
through brackets. e.g.:

     { ->subsetI //. ->ucn_sub //. <-commg_subr. }


Another comment: many of these tedious chained rewrite operations
are not needed if you have powerful "normalization" tactics, e.g.
my tactic "rew_list" which normalizes all kind of list operations
in a canonical way (with a confluent and terminating rewriting system).

ET: Here we discuss about syntax.  Bad.
One thing at a time, I would not make decisions on the language thinking
that the ugly UIs we have today cannot get better.  Eg, we can already have Coq
print intermediate goals in compound rewrite lines (not in PG, or not yet).
Another thing is that, if we are brave enough, we could go toward a new
parsing mode I'm crying for.  In

  rewrite foo !bar [pat]baz

"rewrite" could be a command in itself, activating a parser specific for
rewrite arguments.  "foo" would be 1 complete sentence for this parser, and Coq
could internally represent such state and print it.  "!bar" would be the next
complete sentence... "/something" would be an escape: go back to the standard
parser and parse "something".  No need to put a trailing ".", the UI could ask
Coq to chop the document...

OK, back on earth, all that is very ambitious.  The only thing I'd like to avoid
is that choices made today could seem nonsensical for a system of tomorrow
where parsing + UI interaction is not done as it was done in the 70'.

Unfortunately I think that this box of text goes in the direction of 1 tactic =
1 symbol, that is something I don't like (and also already tried in Matita), to
help with crappy UIs.  Eg, the line above between { ... } is valid Matita:

     ->subsetI // ->ucn_sub // <-commg_subr

You can step trough it item by item.  It sucks, even if it is better than the Coq
one (no . needed).  I strongly prefer the less Perl-ish:

     rewrite subsetI // ucn_sub // -commg_subr

where the mode is stated once per line.
It was not coded like that in Matita because of bad reasons: only 1
un-contextual parser for tactic arguments, lazy/busy coders, too ambiguous for
a single parser.  Result: sprinkle symbols here and there to make it easy to
parse.  Shame on us (Matita developers).

-------------------------