- reparler du clear

- can we access names that were not named explicitly?
  we could do it on names that already come from a forall
  and did not clash

- bullets should have a mode to remove focusing.

- trouver un nom

============================================================
Introduction patterns
   
   x   introduces the next item with name x
 
   ?   introduces the next item with a generated name

   _   introduces and clear the next item, but this clear is
       delayed until the end of the tactic execution (otherwise
       this would cause errors for dependent variables).
       [Alternative: use "{}" a clear intropattern, which would
       be more consistent with the general clear mechanism
       proposed further, namely "{x}" uses the term x and later
       clears it. But maybe it's too heavy, and "_"
       has a well-established meaning in ocaml patterns,
       so we should stick to it.]
  
   >   introduce all the dependent variables that are visible;
       performs hnf if there are none, and fails if hnf does
       not reveal any. [Alternative: do nothing instead of failing.]

   *   introduces all the variables that are visible,
       with fresh names; do nothing if there are none.

   *-  introduces everything until the next mark, including the 
       mark considered for as items for introduction.

   -   expects a mark at the head of the goal, and clears it;
       fails if there is no mark there.
  
   --  decoration intropattern. TODO: is this needed.

   prefix^-  introduces all variables with generated names build
             using inductive name (as obtained from the constructor
             that is carried by the next mark) and by adding "prefix"
             to the front. See further for examples.
             TODO: "-" means until the next mark.
 
   ^suffix-  same as above, except adding a suffix.

   /[ ipat11 .. ipat1N | iipat21 .. | ... ]   

       the above patter to distribution introduction over subgoals;
       the number of subgoals must match the one given.

   /[ ipat11 .. ipat1N | iipat21 .. | ... ]
       
        the last one can be a triple dot that would repeat the last branches
        in the same way as the previous ones.

   /tac            executes the tactic "tac", when "tac" consists
                   of a single identifier.

   /(tac arg)      executes the tactic "tac" with its argument "arg".

   []              shorthand for "/case" 

   [ .. | .. ]     shorthand for "/case /[ .. | .. ]", with an
                   extended interpretation for standard binary
                   operators (/\ and \/ and exists); see further.

Note that spaces are irrelevant between tokens. 

Examples:
    move =>> H
    move =>> /invert [x y H | > H1 H2 | *- ]
    move =>> /invert /[ toto_^- | .. ]
    move =>> /invert /[ -^1 | .. ]

Examples:
    => [H1|H2]
    => /invert /[H1|H2]    
    => /invert [H1|H2]   
    => /eqP H - H2
    case: H => x1 x2 - H


============================================================
Special patterns for tactics  (both for intro and rewrite pattern)


These are convenient notation for common variants of "/tac".

   //               calls "/tactic_slash"; by convention,
                    associated with "some form of automation that
                    may kill the goal".

   /=               calls "/tactic_equal"; by convention, 
                    associated with "some form of normalization".

   /-               calls "/tactic_minus"; by convention,
                    associated with "some form of automation that
                    must kill the goal". 
                    TODO: equivalent to "/done", same as "solve[//]".

   ->               calls "/(rewrite ->)" with the head hypothesis
                    TODO: ambiguité entre "/->" et "/- >"
                          pas un pb car on peut supposer que l'espace joue 
                          un rôle lorsqu'on enchaîne des tokens spéciaux
                          comme "+" qui est différent de "++".
                    TODO: /= serait mieux non? mais du coup,
                          comment réécrire dans l'autre sens?

   <-               calls "/(rewrite <-)" with the head hypothesis

   [occswitch]->    variant

   [occswitch]<-    variant

   /:term           generalize "term" by putting it to the head
                    of the goal (i.e. like "move: term").
               
   /term            apply view (like "view term");

   /tac:(foo)
   /term:(foo)

   /n:tac           shorthand for "/(n:tac)", which applies
                    tactic to the n-th subgoal.


TODO: discuss declaration of lemmas as "Views", with an automatic
promotion as an Ltac tactic.
            View Lemma foo := t.
 equiv to:  Lemma foo := t.   Ltac foo := view_from_lemma foo.

TODO: comment chainer les views si on a l'ambiguité
   Note: one can chain several views at once using the syntax
   "/(~ term1 term2)", since the view tactic, written "~", may
   accept a variable number of arguments.


TODO: rediscuss
   should "[]" do "/invert" always? 
   problem: how to distinguish invert and invert_nosubst?


LATER:
   how many tactics we want to have in practice on intro-patterns => ARTHUR
   

TODO: rediscuss
   => est-ce que c'est un problème d'avoir une ambiguité sur "/" ?
   enrico aime bien
   => /pdivP[p p_prime p_dvdv_X].
   => /invert[H]

Example:
  elim n => [ // | Hind ].
  elim: n => [ [] // | Hind].

Note: one can chain a view with an destructive introduction,
for example if the head hypothesis is "a && b", then one could
do  "move => /~andb[H1 H2]".


Note: one can kill specific subgoals directly in a case analysis,
for example "move => [ /- | > H1 H2 | x H ]" would kill the first 
subgoal and introduce hypotheses in the second and third goals.






============================================================
Destruction of inductive datatypes

- An inductive datatype in general can be destructed using
  the introduction pattern:

           [x1 .. xN | y1 .. yN | ...] 
 
  This pattern raises an error if there are not exactly the
  right number of branches and right number of arguments.
  
- Note: use [x1 +| y1 +] to give only the first names and leave
  the others in the goal.

- Note: use [x1 *-| y1 *-] to give only the first names and 
  introduce the other ones in the hypotheses.

- For the common operators /\ and \/ and "exists", we register
  them as being "right-associative in intropattern". 
  This means that one can destruct the term (A /\ B /\ C)
  as [a b c] instead of [a [b c]]. The formal semantics is: 
  if we have a destructing pattern (starting with a bracket) 
  and if the head constructor of the term being destructed
  is registered as right-associative intropattern,
  and if there are more than 2 names provided, then
  interpret "[a1 a2 .. an]" as "[a1 [a2 .. an]]".

- Example: "A /\ B /\ C" can be decomposed using "[a b c]".

- Example: "exists3 x y z, conj3 A B C" can be decomposed
  using "[a b c]".

- Example: "exists x y z, A /\ B /\ C" can be decomposed
  using "[x y z [a b c]]". 
  
- Remark: we can interpret "exists x y z, A /\ B /\ C"
   as either  "exists x, exists y, exists z, A /\ (B /\ C)"
   or as      "exists3 x y z, conj3 A B C",
   scripts should work either way. In other words, we have a 
   properly of "independence w.r.t. internal representation of
   n-ary conj/disj/exists".

- Example: "A /\ exists x, C x"  CANNOT be decomposed using
  "[a b c]" because the constructor for the second argument 
  is not the same constructor as the one of the current term 
  being destructed.
  


- TODO: rediscuss
    maybe [S=>n|0=>]  as intropattern with named branches.


============================================================
Free introduction patterns


   /+               ... (free)

   /*               ... (free)

   /$               ... (free)

   /&               ... (free)

   /|               ... (free)

   /term            purposely not used, to avoid clashes between
                    terms and tactics




============================================================
Rewrite-patterns

The general form of rewrite is:
  
     rewrite rpat1 ... rpatN
    
with the following rewriting patterns supported:

     term         attemps to rewrite with "term", 
                  TODO: we might add:
                  except if "term" has type "Prop", in which
                  case the rule below applies.
      
                  TODO: pb of interpretation of "rewrite E"  
                  for example when "E : a <-> (b = c)".
                  "E : a -> (b = c)".  not the same as "E : impl a (b = c)"

                  More generally, with setoids...
                  Is it fine to say that the outermost registered
                  setoid symbol should be considered?


     (term=term)  asserts that the equality is true and rewrites using it.
                  The equality becomes a side-condition.
                  TODO: should equality provable by reflexivity be
                  automatically discharged? or they would need "//"?
                  Remark: there is no ambiguity because "term=term"
                  is a term of type "Prop", so rewriting could not
                  TODO: is the syntax "(_:term=term)" too heavy? I think so.
                  => A PRIORI ca suffit de faire la syntaxe
                  => ARTHUR: voir le nombre d'exemple de assert_rewrite.
                  => ENRICO: comment faire: (_ : f ?x = ?x)
                     ENRICO: comment faire: (_ : f ?[x] = ?[x])
                  => GUILLAUME: replace (f ?x) with ?x.
                   

     -term        rewrite back

     &term        unfold term
                  (Note: we cannot use "/" because of conflict
                   with the general notation for tactics)

     -&term       fold term

     !base        autorewrite with a base of lemmas,
                   repeat rewrite in a nonspecified order,
                  naively implemented as a tuple of lemmas
                  possibly optimized for efficiency reasons

                  TODO: have an alternative matching mode,
                  for only matching syntaxically

                     rewrite !base

                  Note: autorewrite does not use ssr rewrite matching.

     [tpat]rpat   is for selecting a term pattern in which the rewriting
                  will take place. See below for examples.
                  Note that outer matching subterms are considered first.
                  TODO: please remind me the logic of giving the target
                  before the rewriting lemma "rewrite E in H" vs "in H rewrite E".

     /tac         execute tactic

     {2}
     -[1 + 3]&(2 + 2).
     (erefl _ : 1 + 3 = 2 + 2)
     


(TODO: i'm trying to guess here)
Target subterms for rewriting: 

   rewrite [foo _ _]E
   => rewrites E inside subterms of the form "foo _ _"

   rewrite [x in foo x _]E
   => rewrites E inside the x in subterms of the form "foo x _"

   TODO: comprendre quel est le besoin ici; et le cas général
   de sélection de sous-terme avec patterns imbriqués (aussi utile 
   pour d'autres tactiques).
   rewrite [bar _ inside (foo _ _)]E
   => rewrites E inside x inside subterms of the form "foo _ _"


TODO: how to do "rewrite E in H" in ssr? 
Is: "on H rewrite E" doing "protect; move: H; rewrite E; intro; unprotect".
Could we make it so that the hypothesis goes back to its original place?




============================================================
Killing false subgoals


   false_goal        replace the goal by "False".

   false             call "false_goal", then try to kill the goal
                     using one of: 
                     - assumption
                     - equal        (new name for "congruence")
                     - inject       (subsumes "discriminate")
                     - cyclic       (proving, e.g. "x <> S x")

   false E          shorthand for "false_goal; apply E".

 

============================================================
Cycles in inductives

   cyclic x         proves a contradiction by exploiting
                    a cycle starting from variable x and
                    going through inductive constructors,
                    e.g. "x = S y /\ y = S x".

   cyclic           equivalent to "try solve [cyclic x]" for every 
                    variable "x" in the goal, but actually more
                    efficient, since a O(n) DFS is possible.

   H:
        P n (S n)
        P (S x) x


============================================================
Inject


   inject_once      takes the head hyp "C x1 x2 = C y1 y2"
   []               and replaces it with "x1 = y1" and "x2 = y2".
                    
                    TODO: if the constructor involves dependent types,
                    then it produces "sigma x1 x2 = sigma y1 y2". or not?

   inject           repeats "inject_once" recursively.
   [H1 [H2 H3]]     "C x1 (D x2 x3) = C y1 (D y2 y3)"
   /inject[^ prefix_ ].   TODO              

   inject: H        shorthand for moving H in the goal first

   inject pat: H    shorthand for moving H in the goal first


TODO: what names to give to tactics that immediately substitute
      the equalities that they produce. "injects" would do this?
      useful for dependent constructors, since there is no other way?


LATER: (is it useful?)
   inject pat       specify a pattern that inject should follow, in order
                    to control the depth. e.g. on 
                    "C x1 (D x2 (E x3)) = C y1 (D y2 (E y3))"
                    we can call "inject [_ [_ _]]" to produce
                    x1 = y1 and x2 = y2 and E x3 = E y3.


============================================================
Invert


   invert         takes the head hyp and performs:  
                  - case analysis, with remembered equalities
                  - calls inject on equalities produced (includes discriminate)
                  - possibly, try to kill goals using tactic "cyclic" 
                  - perform substitutions of fresh variables that
                    are involved in a single equality.

  invert_nosubst  same but does not attempt to perform any substitution

  invert: H       shorthand for moving H down before "invert".                    



General pattern:

  Cstr : forall n1 n2, P f1 f2            f1 and f2 use n1 and n2
  Goal : forall (H: P e1 e2), G H
  Res  : forall n1 n2, (sigma f1 f2 = sigma e1 e2) -> forall (H: P e1 e2) -> G H

Simplified case when the hypothesis is not dependently used:
 
  P : forall x, R x -> T
  Cstr : forall n1 n2, P f1 f2
  Goal : P e1 e2 -> G
  Res  : forall n1 n2, (sigma f1 f2 = sigma e1 e2) -> G

Further simplification P is not dependent,
then sigma is just a tuple operator and injection gives:

  Res  : forall n1 n2, f1 = e1 -> f2 = e2 -> G     ("truc de base")

  already does more than inversion because it adds equalities
  

  inversion does more injection than this.
   S a = S b 
   a = b


=> examples where the default invert does not work well
   because of loss of sharing


Example 0: problematic subsitution of a fresh variable

  Cstr : forall n, A n -> B n -> P n
  Goal : P x -> G
  ResN : forall n, n = x -> A n -> B n -> G
  "obviously good to substitute x instead of fresh n"
  Res  : A x -> B x -> G


Example 1: problematic subsitution of a fresh variable

  Cstr : forall n, A n -> B n -> P n
  Goal : P (big x) -> G
  ResN : forall n, n = big x -> A n -> B n -> G
  Res  : A (big x) -> B (big x) -> G
  

  Res' : let n := big x in A n -> B n -> G



Example 2: problematic subsitution of an existing variable

  Cstr : forall n, P (big n)
  Goal : P x -> A x -> B x -> G
  Res  : forall n, A (big n) -> B (big n) -> G
   => could not work if x occurs elsewhere
   => is it ever desirable to substitute x in existing hypotheses


Example 3: combination of 1 and 2

  Cstr : forall n m, A n -> B n -> P n (big m)
  Goal : P (big x) y -> C y -> D y -> G
  Res  : forall m, A (big x) -> B (big x) -> C (big m) -> D (big m) -> G


Example 4: constructors involving explicit equalities

  Cstr : forall n m, m = big n -> P m
  Goal : P x -> A x -> B x -> G
  Res  : forall n, m = big n -> A m -> B m -> G

  => invert should not remove the equality


Example 5: no canonical choice for which equality to substitute

  Cstr : forall n, A n -> B n -> P n n
  Goal : P (f x) (g y) -> G
  Res  : forall n, n = f x -> n = g y -> A n -> B n -> G

    A (f x)
    A (g y)



Remark: 

  Cstr : forall n, let m := big n in P m m
  => lack of control here.







============================================================
Multipliers

For "rewrite" and "do" tactics

   n!     exactly n times

   n?     up to n times, possible less

   !      as many times as possible, at least once
          (think of it as "_!", i.e. with n not specified)
 
   ?      as many times as possible, possibly zero
          (think of it as "_?", i.e. with n not specified)


============================================================
Tag mechanism on goals

  - tactics attach tags to goals they produce

  - e.g. invert attaches the constructor corresponding name to the case

  - tags are actually list of names, useful e.g. for "invert H1; invert H2".

  - a tactic, call it "goal" or "case", can be used to select one of
    the remaining by a regexp-like on the tag (expects no ambiguity).
  
  - e.g.  "^beta" selects the case coming from constructor "red_expr_beta".


 

============================================================
General clear mechanism


   {x}    denotes the term "x", with the interpretation that
          the variable "x" will be cleared at the end of the
          tactic execution (i.e. at next semi-column).

Examples:  
  - apply {H} x.
  - rewrite H1 {H2}.
  - apply (foo {H}).





============================================================
Discussion on intropatterns.

Can we get away without fast mode, using only ">" to mean
"intro all dependent variables"? Short answer is: yes.

I would write "=>>" wherever I currently write "introv". 
In a few cases, I would need an additional ">" in the list 
of intropatterns. It turns out that there are only a limited number 
of places where I need this throughout TLC. 
I classified these situations that I encountered.


*) Situation 1: unfolding definitions starting with a forall.

Current script: 

   Definition foreach P E :=
      forall x, x \in E -> P x.

   Lemma foreach_weaken : forall P Q E,
     foreach P E -> pred_le P Q -> foreach Q E.
   Proof using. introv H L K. Abort.
   (* Here, K has type "x \in E" *)

Proposed replacement:

   Proof using. =>> H L > K. Abort. 

Remark: this assumes that ">" will call "hnf" if there is
no visible quantifier at all. Otherwise, I'd need to call
/hnf to unfold the head symbol, and write:

   Proof using. =>> H L /hnf > K. Abort. 

Conclusion: the second possibility is a bit heavy, I think
it is fine to assume that ">" will do an unfolding if there
is nothing to introduce.


*) Situation 2: proving elimination lemmas.

Current script:

   Lemma irrefl_neq : forall R,
     irrefl R -> 
     forall x y, R x y -> x <> y. 
   Proof using. introv > H P E. Abort.

Proposed replacement:

   Proof using. =>> H > P E. Abort. 

Conclusion: fair enough to write the extra ">".


*) Situation 3: proving induction principles (similar to above).

   Definition eq_ind_r : forall (P:A -> Prop), 
     P x -> forall y, y = x -> P y.
   Proof using. introv Px H. Abort.

Proposed replacement:

   Proof using. =>> Px > H. Abort. 

Conclusion: fair enough. 


*) Situation 4: lemmas requiring a type to be inhabited 
   even though the statement itself does not use the instance.

   Theorem rec_fixed_point : forall A B {IB:Inhab B} 
    (F:(A->B)->(A->B)) (R:binary A) (P:A->Prop) (S:A->B->Prop) (E:binary B), 
     equiv E -> (forall x, pred_compatible E (S x)) ->
     wf R -> rec_contractive E P F R S ->
     exists (f:A->B), partial_fixed_point E F (Build_partial f P)
                  /\ (forall x, P x -> S x (f x)).
   Proof using. introv IB Equiv Comp WfR Cont. Abort.

Proposed replacement:

   Proof using. =>> IB > Equiv Comp WfR Cont. Abort.

Conclusion: it is a bit unfortunate that I need an extra > here.
One could argue that "Inhab B", if it not dependently used, 
should appear later in the list of hypothesis. But, morally,
I want "an inhabited type B", so I like to have "Inhab B"
to place immediately next to "B".
(Troll: IMO, types should be inhabited by default, like in HOL ;)



TODO: validate the proposal below.

I could live with the additional ">", sure, but it does not look nice.
One possibility would be to do a special case to say that hypotheses 
of the form "Inhab B" are treated as if there were dependently-used
variables. Maybe this would generalize to other typeclasses?
In this case, maybe we can have a command for registering 
patterns of hypotheses that should be considered by ">".
In fact, I would be happy to have just for myself an overloaded
definition of the "plus" tactic. By this I mean that if the
implementation of "=> ipat" when "ipat" is ">" is to call
a tactic "intro_pattern_plus", and that I am able to bind my
own tactic there, I would do:
 
   Ltac intro_pattern_plus :=
      match goal with
      | _ -> _ => idtac
      | Inhab _ -> _ => intro ?; intro_pattern_plus 
      | forall _, _ => intro ?; intro_pattern_plus 
      | _ => hnf; (... same process if a forall a is made visible ...)


   Pseudo Ltac intro_nondeps already_hnf :=
     match goal with
     |- (_ -> _)                       => idtac
     |- (forall _,_)                   => intro ?; intro_nondeps true
     |- _             when already_hnf => idtac
     |- _                              => hnf; intro_nondeps true


   + special case for Arthur:
      | Inhab _ -> _ => intro ?; intro_nondeps true 

============================================================
Need to optimize autorewrite

Autorewrite needs primitive support, and needs cheap syntactic matching
that does not trigger computations.


   Hint Rewrite app_cons app_nil_l app_nil_r app_assoc 
    app_cons_one 
    fold_right_nil fold_right_cons fold_right_app
    fold_right_last 
    fold_left_nil fold_left_cons fold_left_app
    fold_left_last 
    length_nil length_cons length_app length_rev
    length_last 
    rev_nil rev_app rev_cons rev_last rev_rev
    concat_nil concat_app concat_cons concat_last 
     map_nil map_cons map_app map_last 
    mem_nil mem_cons mem_app mem_last 
    mem_cons_eq mem_last_eq 
    keys_nil keys_cons keys_app keys_last
    assoc_cons assoc_here 
    .... : rew_list.

where e.g.:

   Lemma filter_nil : 
     filter f nil = nil.
   Lemma filter_cons : forall x l,
     filter f (x::l) = if f x then x :: filter f l else filter f l.
   Lemma filter_app : forall l1 l2,
     filter f (l1 ++ l2) = filter f l1 ++ filter f l2.
   Lemma filter_last : forall x l,
     filter f (l & x) = filter f l ++ (if f x then x::nil else nil).



============================================================
Rewrite syntax.

TODO: discuss

  => GUILLAUME: find solution for the order of side conditions
    to ensure that we can step execute the chain of rewrites.


Basic principle is that side conditions should come first,
otherwise they stack up at the end.

Problem: for debugging/developping scripts, it is useful to
be able to step-execute series of rewrites.
  
        rewrite E F.
  <->   rewrite E. rewrite F.

However, if rewrite produces side-conditions first, then
we can no longer easily edit this.

        rewrite E F. solveSideOfE. solveSideOfF.
  <->   rewrite E. solveSideOfE. rewrite F. solveSideOfF.


   Concrete example: rewrite E /(side: /-) F.

One solution would be:

        rewrite E /(side: solveSideOfE) F /(side: solveSideOfF).
  <->   rewrite E /(side: solveSideOfE). rewrite F /(side: solveSideOfF).
  <->   rewrite E. solveSideOfE. rewrite F. solveSideOfF.

Another solution is to say that chaining is not such a great
idea anyway, especially when side-conditions are produced.
One could write scripts like:


      rewrite E. rewrite F.
 or   rew E. rew F.
 or   -> E. -> F.

Consider realistic examples before complaining.

       rewrite subsetI ucn_sub // -commg_subr.
  vs   rew subsetI //. rew ucn_sub //. rew -commg_subr.
  vs   ->subsetI //. ->ucn_sub //. <-commg_subr.
   
       rewrite leq_divRL // divn_mulAC leq_divLR dvdn_mulr dvdn_lcmr //.
  vs   -> leq_divRL // divn_mulAC leq_divLR dvdn_mulr dvdn_lcmr //.
  vs   ->leq_divRL//. ->divn_mulAC. ->leq_divLR//. ->dvdn_mulr. ->dvdn_lcmr//.
  vs   ->leq_divRL//. ->divn_mulAC. ->leq_divLR//. ->dvdn_mulr. ->dvdn_lcmr//.

Remark: for stepping through the "main" steps of a proof, you could either
have a shortcut for executing scripts line by line, or for a finer-grained
mechanism, you could use brackets, and have a shortcut for stepping at once
through brackets. e.g.:

     { ->subsetI //. ->ucn_sub //. <-commg_subr. }


Another comment: many of these tedious chained rewrite operations
are not needed if you have powerful "normalization" tactics, e.g.
my tactic "rew_list" which normalizes all kind of list operations
in a canonical way (with a confluent and terminating rewriting system).

ET: Here we discuss about syntax.  Bad.
One thing at a time, I would not make decisions on the language thinking
that the ugly UIs we have today cannot get better.  Eg, we can already have Coq
print intermediate goals in compound rewrite lines (not in PG, or not yet).
Another thing is that, if we are brave enough, we could go toward a new
parsing mode I'm crying for.  In

  rewrite foo !bar [pat]baz

"rewrite" could be a command in itself, activating a parser specific for
rewrite arguments.  "foo" would be 1 complete sentence for this parser, and Coq
could internally represent such state and print it.  "!bar" would be the next
complete sentence... "/something" would be an escape: go back to the standard
parser and parse "something".  No need to put a trailing ".", the UI could ask
Coq to chop the document...

OK, back on earth, all that is very ambitious.  The only thing I'd like to avoid
is that choices made today could seem nonsensical for a system of tomorrow
where parsing + UI interaction is not done as it was done in the 70'.

Unfortunately I think that this box of text goes in the direction of 1 tactic =
1 symbol, that is something I don't like (and also already tried in Matita), to
help with crappy UIs.  Eg, the line above between { ... } is valid Matita:

     ->subsetI // ->ucn_sub // <-commg_subr

You can step trough it item by item.  It sucks, even if it is better than the Coq
one (no . needed).  I strongly prefer the less Perl-ish:

     rewrite subsetI // ucn_sub // -commg_subr

where the mode is stated once per line.
It was not coded like that in Matita because of bad reasons: only 1
un-contextual parser for tactic arguments, lazy/busy coders, too ambiguous for
a single parser.  Result: sprinkle symbols here and there to make it easy to
parse.  Shame on us (Matita developers).


============================================================
TODO: problem of interpretation of arguments of tactics, in particular rewrite.


  I think we can follow CBV semantics.

  By default, ";" or "." forces the resolution of goals that have
  a shape matching a registered "auto-resolution" mechanism.

  In Ltac, we can introduce scopes in which the goals are stacked
  and not resolved before the end of the stack (or explicit resolution).
  Eg.
     Ltac foo := resolution_block (foo; bar).
  would not resolve evars after foo.

  I think this is almost like unshelve, just with good control.
  

     rewrite (H).

  would mean: consider the term "H ?x ?y ?z" with just as many 
  undescores to make a setoid symbol appear at the head. Then,
  rewrite using this term. Then attemps resolution of the evars
  that have been introduced if they are typeclasses. Then fail
  if not all evars are resolved.

     rewrite (H _ x).
  
  would mean: introduce an evar for the underscore, do not
  attempt resolution (even if it is a typeclass), lauch rewrite,
  which should not create further evars, but may instantiate the
  existing ones.
 
     rewrite (resolve (#H _ x)).
  
  would mean: create the term "H ?e x", try to solve "?e" if it
  is a typeclass, then attemps rewriting.

     rewrite (##H _ x).
  
  would mean: create the term "H ?e x", and reabstract arguments,
  giving "forall y, H y x", and then rewrite using this.





============================================================
TODO: other tactics needed in general.




============================================================
TODO: optimization of invert





========================================================================
TODO: Logic operations on goals

[conj]
  Applies to a n-ary conjunction, and splits it into subgoals.
  If the head of the goal is not a conjunction, then hnf is called;
  if the goal is still not a conjunction, then an error is raised.
  If n-ary conjunctions are encoded using a single predicate, then it
  is equivalent to a single call to "constructor".
  If n-ary conjunctions are encoded using binary conjunction, then the
  arity depends on the number of conjunction visible in the goal.
  -- Remark: we could call this tactic "split", but for uniformity with
  all other tactics in this section, it should be called "conj".

[disj i]
  Applies to a n-ary disjunction, and enters the i-th branch 
  (counting from 1).
  If the head of the goal is not a disjunction, then hnf is called;
  if the goal is still not a conjunction, then an error is raised.
  -- Optional: "left"/"right" could be an alias for "disj 1"/"disj 2".

[exists v _ w]
  Applies to an existential goal, and provides witnesses.
  If the goal does not exhibit sufficiently many "exists", 
  hnf is called; if not revealing a existential, an error is raised.
  Underscore are accepted, they stand for fresh evars.
  If is fine to provide fewer witnesses than the number of visible
  existentials.

[iff]
  Applies to a goal of the form "P <-> Q", it leaves two subgoals
  "P -> Q" and "Q -> P".
  If the goal is of the form "forall ..., P <-> Q", then it leaves 
  two subgoals subgoals:  "forall ..., P -> Q" and "forall ..., Q -> P".
  If the goal is not of any of these forms, then unfolding is performed
  until exhibiting a "<->". An error is raised otherwise.

  -- Example usage: "iff => [M1|(M2 M3)]"  on "P <-> (Q /\ R)".
 
  The behavior of [iff] can be extended by libraries/users in order
  to make it applicable to apply extensionality, e.g.:
  - "forall ..., P = Q :> Prop"   (assuming predicate extensionality)
  - "forall ..., b = b' :> bool"  (producing b -> b' and b' -> b)
  - "forall ..., E = F :> set A"  (producing "forall x, x \in E -> x \in F", and reciprocal)

[true] 
  Applies to a goal of the form "True", and discharges it.
  Also applies to a goal of the form "forall ..., True".
  If the goal cannot be put in this form, the tactic fails.
  The behavior can be extended by libraries or by the user 
  to prove other goals that can be proved true without 
  producing any further subgoals.
  Remark: we need to introduce a variant of the "hint" mechanism 
  that binds tactics as "extern hints" for specific tactics.

[false]  -- UPDATE: see specific section about "false" above.
  Applies to any goal. It replaces the goal with "False".
  The tactic can be extended by libraries or by the user
  to prove contradictions. By default, the tactic executes
     try solve [ assumption | discriminate | congruence ].
   [false E]
   Applies to any goal. It replaces the goal with "False",
   and applies lemma E to the goal.

[absurd]
  Tactic specific to classical logic ("the goal would be absurd").
  Applies to any goal "G", and replaces it with "~ G -> False". 
  Typical usage is "absurd => M."

[absurd E]
  Tactics applies to any goal, and replaces it with "~ T",
  where T is the type of expression E.
  Typical usage: "absurd {H}", where "H" is an hypothesis.
  It the goal becomes of the form "C ... <> C' ...", where
  C and C' are distinct constructors, the goal is automatically
  discharged.



========================================================================
Logical cuts -- TODO: polish first before discussion

[prove T]
[prove I: T]   
   -- Remark: "prove" is a new name instead of "assert" or "have" whose intent is 
      less obvious than "clear", imo.
   "prove T" applies to any goal G. It produces a subgoal T, and a subgoal T->G.
   "prove I: T" is a shorthand for "prove T; [|=>I]".

   Here, T is provided in open syntax, meaning that parentheses are not needed.
   E.g.:  prove I: forall (x y : unit), x = y.


[suffice T] // optional
[suffice I: T] 
   "suffice T"    is a shorthand for "prove T; swap 1 2".
   "suffice I: T" is a shorthand for "prove I: T; swap 1 2".
   where "swap 1 2" swaps the two subgoals generated.


========================================================================
Application

[exact H] 
   equivalent to current [refine]. TODO: specify more precisely.

[apply H] 
   Applies the hypothesis H to the goal. 
   
   --TODO: What is the specification? 
     is there a better way than saying that it tries to apply
     "refine (H _ _ _)"  for increasing numbers of underscores?
     
   Here, the term "H" can be provided in open syntax, meaning that 
   parentheses are not needed. In particular,
   "apply H x y z"  is a shorthand for "apply (H x y z)"
   "apply $H x y z" is a shorthand for "apply ($H x y z)"

   Remark: "apply {H}" applies hypothesis H then clears it.

[constr] 
  Applies to a goal "P EX1 .. EN" where P is inductively-defined.
  Applies the only constructor of this inductive data type for which
  the invokation of the tactic "apply E" succeeds.

  ---Optional (not recommended imo): specification of [constr] for builtin types:
  - "constr" on a n-ary conjunction is the same as "conj".
  - "constr" on an equivalence is the same as "iff".
  - "constr" on an existential is the same as "exists _".

  ---Technical remark: implemented as "exactly_once econstructor", 
  that is, like "econstructor", but fails if more than one constructor 
  could be applied.


========================================================================
Equality and rewriting

[rewrite p]   
   See specific section.
      
[subst x]
  Substitute away the equality for "x".
  If there are attemps of recursive substitution, substitute everywhere
  where possible, and keep the hypothesis involving the equality on x.

[equal]
  Invokes the congruence tactic, which may solve the goal.
  Otherwise, if the goal of the form [f a b = f' a' b'],
  then it calls "fequal", and try "congruence" on every subgoal.
  This tactic never fails; if it can't make progress it does nothing.
  --> TODO: I am not sure this is the desired behavior; often, it is
      much better to have tactic fail when they do not progress;
      we could give this alternative spec. Opinion?

  -- Suggested implementation: equivalent to "try fequal; congruence"?

  -- Remark: this covers [reflexivity], [fequal] and [congruence].

  ==> TODO: what is the connection with "congr" from ssr?




========================================================================
Induction

--> Naming: I think "induct" says as much as "induction", and "invert" as much
    as "inversion". After all, we have a tactic called "apply" and it
    is not called "application", for a good reason imo...

[induct H]
  Like Coq induction, but 
  - saves the arguments that are not variables, by introducing equalities
  - produces all hypotheses in the goal, including induction principles

[induct_wf: R E]
  Helper for performing induction on a well-founded relation R.
  The expression E is the argument in the goal which is to be proved
  accessible w.r.t. the well-founded relation R.
  -- Implementation: "set (X:=E); pattern X; apply (well_founded_ind E); clear X".

[induct_wf X IH: R] // only useful to advanced users 
   Shorthand for "induction_wf: R X => IH X".




========================================================================
Goal management tactics

[admit]
  Skips the current goal.
  -- Implemented by creating an evar that is in a special shelf,
     the shelf of admitted subgoals.


========================================================================
OTHER:
** goal reordering
  --> like in ssr? what about Coq's new features? TODO!

** variable renaming
  --> do we want to keep the syntax [rename x1 into y1, x2 into y2]
  --> Note that renaming for hypotheses works with "move: H1 H2 => M1 M2",
      but this can't be done so easily for variables in a neat way.
  

========================================================================
For advanced users only

[tryfalse]
  useful shorthand for "try solve [false]".

[exists_all]
  equivalent to [exists _ _ _] with as many existentials as visible in the goal.

[unfold] (without any argument)
  unfolds the head symbol of the first hypothesis in the goal;
  or the head symbol of the conclusion if there is no hypothesis,
  or the head symbol of the first argument if the goal is an equality.

[unfold in H]
   same as above, but for an hypothesis.

[case_if] / [case_match]
  performs case analysis on the first if/match in the goal

[flexible p]
   where p is a pattern: replaces the occurences of "p" with fresh evars.
   For example on the goal "P (3*x) y", the tactic "flex (_*_)" will give
   the goal "P ?a y" and subgoal "?a = 3*x".

   If the equality subgoal can be proved by proof irrelevance and the
   proof irrelevance axiom is available, then this goal is discharged.
   Equivalent to TLC "equates", and allows to do TLC's "applys_eq",
   and also TLC's "pi_rewrite".

[equal_rec]
  shorthand for [repeat (progress equal)], useful to prove in depth
  equalities, e.g. in a goal  "f (g x y) z = f (g x' y) z".


========================================================================
Questions:

==> how to do TLC's "sets_eq" tactic.
