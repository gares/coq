
============================================================
Introduction patterns
   
   x   introduces the next item with name x
 
   ?   introduces the next item with a generated name

   _   introduces and clear the next item, but this clear is
       delayed until the end of the tactic execution (otherwise
       this would cause errors for dependent variables).
       [Alternative: use "{}" a clear intropattern, which would
       be more consistent with the general clear mechanism
       proposed further, namely "{x}" uses the term x and later
       clears it. But maybe it's too heavy, and "_"
       has a well-established meaning in ocaml patterns,
       so we should stick to it.]
  
   +   introduce all the dependent variables that are visible;
       performs hnf if there are none, and fails if hnf does
       not reveal any. [Alternative: do nothing instead of failing.]

   *   introduces all the variables that are visible,
       with fresh names; do nothing if there are none.

   *-  introduces everything until the next mark, including the mark

   -   expects a mark at the head of the goal, and clears it;
       fails if there is no mark there.

   prefix^-  introduces all variables with generated names build
             using inductive name (as obtained from the constructor
             that is carried by the next mark) and by adding "prefix"
             to the front. See further for examples.
 
   ^suffix-  same as above, except adding a suffix.

   /[ ipat11 .. ipat1N | iipat21 .. | ... ]   

       the above patter to distribution introduction over subgoals;
       the number of subgoals must match the one given.

   /tac            executes the tactic "tac", when "tac" consists
                   of a single identifier.

   /(tac arg)      executes the tactic "tac" with its argument "arg".

   []              shorthand for "/case" 

   [ .. | .. ]     shorthand for "/case /[ .. | .. ]", with an
                   extended interpretation for standard binary
                   operators (/\ and \/ and exists); see further.

Note that spaces are irrelevant between tokens. 

Examples:
    move =>+ H
    move =>+ /invert [x y H | + H1 H2 | *- ]



============================================================
Special patterns for tactics  (both for intro and rewrite pattern)


These are convenient notation for common variants of "/tac".

   //               calls the tactic "slash_slash"; by convention,
                    associated with "some form of automation that
                    may kill the goal".

   /=               calls the tactic "slash_equal"; by convention, 
                    associated with "some form of normalization".

   /-               calls the tactic "slash_minus"; by convention,
                    associated with "some form of automation that
                    must kill the goal".
    
   /->              calls "rewrite ->" with the head hypothesis
                    TODO: ambiguité entre "/->" et "/- >"
                          pas un pb car on peut supposer que l'espace joue 
                          un rôle lorsqu'on enchaîne des tokens spéciaux
                          comme "+" qui est différent de "++".
                    TODO: /= serait mieux non? mais du coup,
                          comment réécrire dans l'autre sens?

   /<-              calls "rewrite <-" with the head hypothesis

   /[occswitch]->   variant

   /[occswitch]<-   variant

   /:term           generalize "term" by putting it to the head
                    of the goal (i.e. like "move: term").
               
   /~term           apply view (like "view term");
                    TODO: would "/=" be better here? if so, can
                    swap it with "/~".

   /n:tac           shorthand for "/(n:tac)", which applies
                    tactic to the n-th subgoal.


Note: one can chain a view with an destructive introduction,
for example if the head hypothesis is "a && b", then one could
do  "move => /~andb[H1 H2]".

Note: one can chain several views at once using the syntax
"/(~ term1 term2)", since the view tactic, written "~", may
accept a variable number of arguments.

Note: one can kill specific subgoals directly in a case analysis,
for example "move => [ /- | > H1 H2 | x H ]" would kill the first 
subgoal and introduce hypotheses in the second and third goals.



============================================================
Destruction of inductive datatypes

- An inductive datatype in general can be destructed using
  the introduction pattern:

           [x1 .. xN | y1 .. yN | ...] 
 
  This pattern raises an error if there are not exactly the
  right number of branches and right number of arguments.
  
- Note: use [x1 +| y1 +] to give only the first names and leave
  the others in the goal.

- Note: use [x1 *-| y1 *-] to give only the first names and 
  introduce the other ones in the hypotheses.

- For the common operators /\ and \/ and "exists", we register
  them as being "right-associative in intropattern". 
  This means that one can destruct the term (A /\ B /\ C)
  as [a b c] instead of [a [b c]]. The formal semantics is: 
  if we have a destructing pattern (starting with a bracket) 
  and if the head constructor of the term being destructed
  is registered as right-associative intropattern,
  and if there are more than 2 names provided, then
  interpret "[a1 a2 .. an]" as "[a1 [a2 .. an]]".

- Example: "A /\ B /\ C" can be decomposed using "[a b c]".

- Example: "exists3 x y z, conj3 A B C" can be decomposed
  using "[a b c]".

- Example: "exists x y z, A /\ B /\ C" can be decomposed
  using "[x y z [a b c]]". 
  
- Remark: we can interpret "exists x y z, A /\ B /\ C"
   as either  "exists x, exists y, exists z, A /\ (B /\ C)"
   or as      "exists3 x y z, conj3 A B C",
   scripts should work either way. In other words, we have a 
   properly of "independence w.r.t. internal representation of
   n-ary conj/disj/exists".

- Example: "A /\ exists x, C x"  CANNOT be decomposed using
  "[a b c]" because the constructor for the second argument 
  is not the same constructor as the one of the current term 
  being destructed.
  


- TODO: maybe [S=>n|0=>]  as intropattern


============================================================
Free introduction patterns


   /+               ... (free)

   /*               ... (free)

   /$               ... (free)

   /&               ... (free)

   /|               ... (free)

   /term            purposely not used, to avoid clashes between
                    terms and tactics





============================================================
Rewrite-patterns

The general form of rewrite is:
  
     rewrite rpat1 ... rpatN
    
with the following rewriting patterns supported:

     term         attemps to rewrite with "term", 
                  TODO: we might add:
                  except if "term" has type "Prop", in which
                  case the rule below applies.
      
                  TODO: pb of interpretation of "rewrite E"  
                  for example when "E : a <-> b = c".
                  More generally, with setoids...
                  Is it fine to say that the outermost registered
                  setoid symbol should be considered?


     (term=term)  asserts that the equality is true and rewrites using it.
                  The equality becomes a side-condition.
                  TODO: should equality provable by reflexivity be
                  automatically discharged? or they would need "//"?
                  Remark: there is no ambiguity because "term=term"
                  is a term of type "Prop", so rewriting could not
                  TODO: is the syntax "(_:term=term)" too heavy? I think so.

     -term

                  TODO: ->term  et <-term  auraient du sens par
                  uniformité avec les intro-patterns, si on utilise
                  /-> et /<- 

     &term        unfold term
                  (Note: we cannot use "/" because of conflict
                   with the general notation for tactics)

     -&term       fold term

     ~term        rewrite with a view; equivalent to "/~term"
                  TODO: maybe this is not needed if views are equalities?

     =base        autorewrite with a base of lemmas

     [tpat]rpat   is for selecting a term pattern in which the rewriting
                  will take place. See below for examples.
                  Note that outer matching subterms are considered first.
                  TODO: please remind me the logic of giving the target
                  before the rewriting lemma "rewrite E in H" vs "in H rewrite E".

     /tac         execute tactic


Target subterms for rewriting: (TODO: i'm trying to guess here)

   rewrite [foo _ _]E
   => rewrites E inside subterms of the form "foo _ _"

   rewrite [x in foo x _]E
   => rewrites E inside the x in subterms of the form "foo x _"

   TODO: comprendre quel est le besoin ici; et le cas général
   de sélection de sous-terme avec patterns imbriqués (aussi utile 
   pour d'autres tactiques).
   rewrite [bar _ inside (foo _ _)]E
   => rewrites E inside x inside subterms of the form "foo _ _"


TODO: how to do "rewrite E in H" in ssr? 
Is: "on H rewrite E" doing "protect; move: H; rewrite E; intro; unprotect".
Could we make it so that the hypothesis goes back to its original place?





============================================================
Killing false subgoals


   false_goal        replace the goal by "False".

   false             call "false_goal", then try to kill the goal
                     using one of: 
                     - assumption
                     - equal        (new name for "congruence")
                     - inject       (subsumes "discriminate")
                     - cyclic       (proving, e.g. "x <> S x")

   false E          shorthand for "false_goal; apply E".

 

============================================================
Cycles in inductives

   cyclic x         proves a contradiction by exploiting
                    a cycle starting from variable x and
                    going through inductive constructors,
                    e.g. "x = S y /\ y = S x".

   cyclic           equivalent to "try solve [cyclic x]" for every 
                    variable "x" in the goal, but actually more
                    efficient, since a O(n) DFS is possible.



============================================================
Inject


   inject_once      takes the head hyp "C x1 x2 = C y1 y2"
                    and replaces it with "x1 = y1" and "x2 = y2".
                    
                    TODO: if the constructor involves dependent types,
                    then it produces "sigma x1 x2 = sigma y1 y2". or not?

   inject           repeats "inject" recursively.

   inject: H        shorthand for moving H in the goal first

   inject pat: H    shorthand for moving H in the goal first


TODO: what names to give to tactics that immediately substitute
      the equalities that they produce. "injects" would do this?
      useful for dependent constructors, since there is no other way?


LATER: (is it useful?)
   inject pat       specify a pattern that inject should follow, in order
                    to control the depth. e.g. on 
                    "C x1 (D x2 (E x3)) = C y1 (D y2 (E y3))"
                    we can call "inject [_ [_ _]]" to produce
                    x1 = y1 and x2 = y2 and E x3 = E y3.


============================================================
Invert


   invert         takes the head hyp and performs:  
                  - case analysis, with remembered equalities
                  - calls inject on equalities produced (includes discriminate)
                  - possibly, try to kill goals using tactic "cyclic" 
                  - perform substitutions of fresh variables that
                    are involved in a single equality.

  invert_nosubst  same but does not attempt to perform any substitution

  invert: H       shorthand for moving H down before "invert".                    



General pattern:

  Cstr : forall n1 n2, P f1 f2
  Goal : forall (H: P e1 e2), G H
  Res  : forall n1 n2, (sigma f1 f2 = sigma e1 e2) -> (H: P e1 e2) -> G H

Simplified case when the hypothesis is not dependently used:

  Cstr : forall n1 n2, P f1 f2
  Goal : P e1 e2 -> G
  Res  : forall n1 n2, (sigma f1 f2 = sigma e1 e2) -> G

Further simplification P is not dependent,
then sigma is just a tuple operator and injection gives:

  Res  : forall n1 n2, f1 = e1 -> f2 = e2 -> G


Example 1: problematic subsitution of a fresh variable

  Cstr : forall n, A n -> B n -> P n
  Goal : P (big x) -> G
  Res  : A (big x) -> B (big x) -> G


Example 2: problematic subsitution of an existing variable

  Cstr : forall n, P (big n)
  Goal : P x -> A x -> B x -> G
  Res  : forall n, A (big n) -> B (big n) -> G


Example 3: combination of 1 and 2

  Cstr : forall n m, A n -> B n -> P n (big m)
  Goal : P (big x) y -> C y -> D y -> G
  Res  : forall m, A (big x) -> B (big x) -> C (big m) -> D (big m) -> G


Example 4: constructors involving explicit equalities

  Cstr : forall n m, m = big n -> P m
  Goal : P x -> A x -> B x -> G
  Res  : forall n, m = big n -> A m -> B m -> G


Example 5: no canonical choice for which equality to substitute

  Cstr : forall n, A n -> B n -> P n n
  Goal : P (big x) (big y) -> G
  Res  : forall n, A n -> n = big x -> n = big y -> G



============================================================
Multipliers

For "rewrite" and "do" tactics

   n!     exactly n times

   n?     up to n times, possible less

   !      as many times as possible, at least once
          (think of it as "_!", i.e. with n not specified)
 
   ?      as many times as possible, possibly zero
          (think of it as "_?", i.e. with n not specified)


============================================================
Tag mechanism on goals

  - tactics attach tags to goals they produce

  - e.g. invert attaches the constructor corresponding name to the case

  - tags are actually list of names, useful e.g. for "invert H1; invert H2".

  - a tactic, call it "goal" or "case", can be used to select one of
    the remaining by a regexp-like on the tag (expects no ambiguity).
  
  - e.g.  "^beta" selects the case coming from constructor "red_expr_beta".


 

============================================================
General clear mechanism


   {x}    denotes the term "x", with the interpretation that
          the variable "x" will be cleared at the end of the
          tactic execution (i.e. at next semi-column).

Examples:  
  - apply {H} x.
  - rewrite H1 {H2}.
  - apply (foo {H}).





============================================================
Discussion on intropatterns.

Can we get away without fast mode, using only "+" to mean
"intro all dependent variables"? Short answer is: yes.

I would write "=>+" wherever I currently write "introv". 
In a few cases, I would need an additional "+" in the list 
of intropatterns. It turns out that there are only a limited number 
of places where I need this throughout TLC. 
I classified these situations that I encountered.


*) Situation 1: unfolding definitions starting with a forall.

Current script: 

   Definition foreach P E :=
      forall x, x \in E -> P x.

   Lemma foreach_weaken : forall P Q E,
     foreach P E -> pred_le P Q -> foreach Q E.
   Proof using. introv H L K. Abort.
   (* Here, K has type "x \in E" *)

Proposed replacement:

   Proof using. =>+ H L + K. Abort. 

Remark: this assumes that "+" will call "hnf" if there is
no visible quantifier at all. Otherwise, I'd need to call
/hnf to unfold the head symbol, and write:

   Proof using. =>+ H L /hnf + K. Abort. 

Conclusion: the second possibility is a bit heavy, I think
it is fine to assume that "+" will do an unfolding if there
is nothing to introduce.


*) Situation 2: proving elimination lemmas.

Current script:

   Lemma irrefl_neq : forall R,
     irrefl R -> 
     forall x y, R x y -> x <> y. 
   Proof using. introv + H P E. Abort.

Proposed replacement:

   Proof using. =>+ H + P E. Abort. 

Conclusion: fair enough to write the extra "+".


*) Situation 3: proving induction principles (similar to above).

   Definition eq_ind_r : forall (P:A -> Prop), 
     P x -> forall y, y = x -> P y.
   Proof using. introv Px H. Abort.

Proposed replacement:

   Proof using. =>+ Px + H. Abort. 

Conclusion: fair enough. 


*) Situation 4: lemmas requiring a type to be inhabited 
   even though the statement itself does not use the instance.

   Theorem rec_fixed_point : forall A B {IB:Inhab B} 
    (F:(A->B)->(A->B)) (R:binary A) (P:A->Prop) (S:A->B->Prop) (E:binary B), 
     equiv E -> (forall x, pred_compatible E (S x)) ->
     wf R -> rec_contractive E P F R S ->
     exists (f:A->B), partial_fixed_point E F (Build_partial f P)
                  /\ (forall x, P x -> S x (f x)).
   Proof using. introv IB Equiv Comp WfR Cont. Abort.

Proposed replacement:

   Proof using. =>+ IB + Equiv Comp WfR Cont. Abort.

Conclusion: it is a bit unfortunate that I need an extra + here.
One could argue that "Inhab B", if it not dependently used, 
should appear later in the list of hypothesis. But, morally,
I want "an inhabited type B", so I like to have "Inhab B"
to place immediately next to "B".
(Troll: IMO, types should be inhabited by default, like in HOL ;)


I could live with the additional "+", sure, but it does not look nice.
One possibility would be to do a special case to say that hypotheses 
of the form "Inhab B" are treated as if there were dependently-used
variables. Maybe this would generalize to other typeclasses?
In this case, maybe we can have a command for registering 
patterns of hypotheses that should be considered by "+".
In fact, I would be happy to have just for myself an overloaded
definition of the "plus" tactic. By this I mean that if the
implementation of "=> ipat" when "ipat" is "+" is to call
a tactic "intro_pattern_plus", and that I am able to bind my
own tactic there, I would do:
 
   Ltac intro_pattern_plus :=
      match goal with
      | _ -> _ => idtac
      | Inhab _ -> _ => intro ?; intro_pattern_plus 
      | forall _, _ => intro ?; intro_pattern_plus 
      | _ => hnf; (... same process if a forall a is made visible ...)



============================================================
Need to optimize autorewrite

Autorewrite needs primitive support, and needs cheap syntactic matching
that does not trigger computations.


   Hint Rewrite app_cons app_nil_l app_nil_r app_assoc 
    app_cons_one 
    fold_right_nil fold_right_cons fold_right_app
    fold_right_last 
    fold_left_nil fold_left_cons fold_left_app
    fold_left_last 
    length_nil length_cons length_app length_rev
    length_last 
    rev_nil rev_app rev_cons rev_last rev_rev
    concat_nil concat_app concat_cons concat_last 
     map_nil map_cons map_app map_last 
    mem_nil mem_cons mem_app mem_last 
    mem_cons_eq mem_last_eq 
    keys_nil keys_cons keys_app keys_last
    assoc_cons assoc_here 
    .... : rew_list.

where e.g.:

   Lemma filter_nil : 
     filter f nil = nil.
   Lemma filter_cons : forall x l,
     filter f (x::l) = if f x then x :: filter f l else filter f l.
   Lemma filter_app : forall l1 l2,
     filter f (l1 ++ l2) = filter f l1 ++ filter f l2.
   Lemma filter_last : forall x l,
     filter f (l & x) = filter f l ++ (if f x then x::nil else nil).



============================================================
Rewrite syntax.


Problem: for debugging/developping scripts, it is useful to
be able to step-execute series of rewrites.
  
        rewrite E F.
  <->   rewrite E. rewrite F.

However, if rewrite produces side-conditions first, then
we can no longer easily edit this.

        rewrite E F. solveSideOfE. solveSideOfF.
  <->   rewrite E. solveSideOfE. rewrite F. solveSideOfF.

One solution would be:

        rewrite E /(side: solveSideOfE) F /(side: solveSideOfF).
  <->   rewrite E /(side: solveSideOfE). rewrite F /(side: solveSideOfF).
  <->   rewrite E. solveSideOfE. rewrite F. solveSideOfF.

Another solution is to say that chaining is not such a great
idea anyway, especially when side-conditions are produced.
One could write scripts like:


      rewrite E. rewrite F.
 or   rew E. rew F.
 or   -> E. -> F.

Consider realistic examples before complaining.

       rewrite subsetI ucn_sub // -commg_subr.
  vs   rew subsetI //. rew ucn_sub //. rew -commg_subr.
  vs   ->subsetI //. ->ucn_sub //. <-commg_subr.
   
       rewrite leq_divRL // divn_mulAC leq_divLR dvdn_mulr dvdn_lcmr //.
  vs   -> leq_divRL // divn_mulAC leq_divLR dvdn_mulr dvdn_lcmr //.
  vs   ->leq_divRL//. ->divn_mulAC. ->leq_divLR//. ->dvdn_mulr. ->dvdn_lcmr//.
  vs   ->leq_divRL//. ->divn_mulAC. ->leq_divLR//. ->dvdn_mulr. ->dvdn_lcmr//.

Remark: for stepping through the "main" steps of a proof, you could either
have a shortcut for executing scripts line by line, or for a finer-grained
mechanism, you could use brackets, and have a shortcut for stepping at once
through brackets. e.g.:

     { ->subsetI //. ->ucn_sub //. <-commg_subr. }


Another comment: many of these tedious chained rewrite operations
are not needed if you have powerful "normalization" tactics, e.g.
my tactic "rew_list" which normalizes all kind of list operations
in a canonical way (with a confluent and terminating rewriting system).

ET: Here we discuss about syntax.  Bad.
One thing at a time, I would not make decisions on the language thinking
that the ugly UIs we have today cannot get better.  Eg, we can already have Coq
print intermediate goals in compound rewrite lines (not in PG, or not yet).
Another thing is that, if we are brave enough, we could go toward a new
parsing mode I'm crying for.  In

  rewrite foo !bar [pat]baz

"rewrite" could be a command in itself, activating a parser specific for
rewrite arguments.  "foo" would be 1 complete sentence for this parser, and Coq
could internally represent such state and print it.  "!bar" would be the next
complete sentence... "/something" would be an escape: go back to the standard
parser and parse "something".  No need to put a trailing ".", the UI could ask
Coq to chop the document...

OK, back on earth, all that is very ambitious.  The only thing I'd like to avoid
is that choices made today could seem nonsensical for a system of tomorrow
where parsing + UI interaction is not done as it was done in the 70'.

Unfortunately I think that this box of text goes in the direction of 1 tactic =
1 symbol, that is something I don't like (and also already tried in Matita), to
help with crappy UIs.  Eg, the line above between { ... } is valid Matita:

     ->subsetI // ->ucn_sub // <-commg_subr

You can step trough it item by item.  It sucks, even if it is better than the Coq
one (no . needed).  I strongly prefer the less Perl-ish:

     rewrite subsetI // ucn_sub // -commg_subr

where the mode is stated once per line.
It was not coded like that in Matita because of bad reasons: only 1
un-contextual parser for tactic arguments, lazy/busy coders, too ambiguous for
a single parser.  Result: sprinkle symbols here and there to make it easy to
parse.  Shame on us (Matita developers).

============================================================
TODO: problem of interpretation of arguments of tactics.




============================================================
TODO: other tactics needed in general.


