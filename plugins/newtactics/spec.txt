
TODO => need to find a cool name for the new tactic set

TODO => disable automatic focusing on bullets;
        put an option (or IDE option) to activate it.




============================================================
Introduction patterns
   
   x   introduces the next item with name x
 
   ?   introduces the next item with a generated name

   _   introduces and clear the next item, but this clear is
       delayed until the end of the tactic execution (otherwise
       this would cause errors for dependent variables).
       [Alternative: use "{}" a clear intropattern, which would
       be more consistent with the general clear mechanism
       proposed further, namely "{x}" uses the term x and later
       clears it. But maybe it's too heavy, and "_"
       has a well-established meaning in ocaml patterns,
       so we should stick to it.]
  
   >   introduce all the dependent variables that are visible;
       performs hnf if there are none, and do nothing otherwise.
       Alternative: fail instead of doing nothing. [TODO: choose]

   *   introduces all the variables that are visible,
       with fresh names; do nothing if there are none.

   *-  introduces everything until the next mark, including the 
       mark considered for as items for introduction.

   -   expects a mark at the head of the goal, and clears it;
       fails if there is no mark there.
  
   --  decoration intropattern. TODO: is this needed?

   prefix^-  introduces all variables with generated names build
             using inductive name (as obtained from the constructor
             that is carried by the next mark) and by adding "prefix"
             to the front. See further for examples.
             TODO: "-" means until the next mark.
 
   ^suffix-  same as above, except adding a suffix.

   /[ ipat11 .. ipat1N | iipat21 .. | ... ]   

       the above patter to distribution introduction over subgoals;
       the number of subgoals must match the one given.

   /[ ipat11 .. ipat1N | iipat21 .. | ... ]
       
        the last one can be a triple dot that would repeat the last branches
        in the same way as the previous ones.

   []              shorthand for "/case".
                   TODO: suggestion that this could be "/invert"
                   by default.

   [ .. | .. ]     shorthand for "/case /[ .. | .. ]", with an
                   extended interpretation for standard binary
                   operators (/\ and \/ and exists); see further.

   /tac            executes the tactic "tac", when "tac" consists
                   of a single identifier.
                   TODO: do we have strong argument for justifying
                   the need of this generality? but first, do we 
                   need to argue, if we can provide generalitye easily?

   /(tac arg)      executes the tactic "tac" with its argument "arg".
                       
   /n:tac          shorthand for "/(n:tac)", which applies
                   tactic to the n-th subgoal.
                   General form: "/n:(tac arg)".

   //              calls "/tactic_slash"; by convention,
                   associated with "some form of automation that
                   may kill the goal".

   /-              calls "/tactic_minus"; by convention,
                   associated with "some form of automation that
                   must kill the goal". 
                   Same as "/(solve[tactic_slash])".

   /=              calls "/tactic_equal"; by convention, 
                   associated with "some form of normalization".

   ->              calls "/(rewrite ->)" with the head hypothesis,
                   and clears this hypothesis.
                   Generalization: [occswitch]->. 

   <-              calls "/(rewrite <-)" with the head hypothesis
                   and clears this hypothesis.
                   Generalization: [occswitch]<-.
              
   /view           Apply the view "view". Equivalent to:
                      intro H; move: (regeneralize_constr:(#view H)).
                   Proposal 1: ambiguity between term and tactics,
                      possibly resolved by /tac:(foo) /term:(foo).
                   Proposal 2: view lemmas are declared using the
                      syntax "View Lemma foo" or "Add Existing View foo",
                      and then "foo" becomes a propert tactic, so "/foo"
                      is parse like "/tac".
                   TODO: discuss proposals.


Note that spaces between tokens are irrelevant. 


Examples:
    move =>> H
    move =>> /invert [x y H | > H1 H2 | *- ]
    move =>> /invert /[ toto_^- | .. ]
    move =>> /invert /[ -^1 | .. ]


Examples:
    => /andb[H1 H2]    on the goal "a && b -> G"
    => [H1|H2]
    => /invert /[H1|H2]    
    => /invert [H1|H2]  
    => /invert[H]
    => /eqP H - H2                  --TODO: add comment   
    => /pdivP[p p_prime p_dvdv_X]   --TODO: add comment
    case: H => x1 x2 - H

Examples:
  elim n => [ // | Hind ].
  elim: n => [ [] // | Hind].

  induct M => [ /- | > H1 H2 | x H ].
     kill the first subgoal, introduction in others.


Proposal: have a mode that bans access to generated names, except
in the typical case where the name comes from a "forall" statement
and this name could be introduced without clash.


Proposals for chaining views without making the space relevant:
      /view1 /view2          (view1, then view2)
  vs  /(view view1 view2)    (composed view)
  vs  /view1~/view2          (composed view, without too much overhead)
  where "view" is the name of the tactic that takes a variable
  number of terms as arguments, and apply the composed view.
  TODO:  discuss.


TODO: is this intro pattern useful? maybe not.

   /:term           generalize "term" by putting it to the head
                    of the goal. Equivalent to /(move: term).


============================================================
Free introduction patterns


   /+               ... (free)

   /*               ... (free)

   /$               ... (free)

   /&               ... (free)

   /|               ... (free)



============================================================
Destruction of inductive datatypes

- An inductive datatype in general can be destructed using
  the introduction pattern:

           [x1 .. xN | y1 .. yN | ...] 
 
  This pattern raises an error if there are not exactly the
  right number of branches and right number of arguments.
  
- Note: use [x1 +| y1 +] to give only the first names and leave
  the others in the goal.

- Note: use [x1 *-| y1 *-] to give only the first names and 
  introduce the other ones in the hypotheses.

- For the common operators /\ and \/ and "exists", we register
  them as being "right-associative in intropattern". 
  This means that one can destruct the term (A /\ B /\ C)
  as [a b c] instead of [a [b c]]. The formal semantics is: 
  if we have a destructing pattern (starting with a bracket) 
  and if the head constructor of the term being destructed
  is registered as right-associative intropattern,
  and if there are more than 2 names provided, then
  interpret "[a1 a2 .. an]" as "[a1 [a2 .. an]]".

- Example: "A /\ B /\ C" can be decomposed using "[a b c]".

- Example: "exists3 x y z, conj3 A B C" can be decomposed
  using "[a b c]".

- Example: "exists x y z, A /\ B /\ C" can be decomposed
  using "[x y z [a b c]]". 
  
- Remark: we can interpret "exists x y z, A /\ B /\ C"
   as either  "exists x, exists y, exists z, A /\ (B /\ C)"
   or as      "exists3 x y z, conj3 A B C",
   scripts should work either way. In other words, we have a 
   properly of "independence w.r.t. internal representation of
   n-ary conj/disj/exists".

- Example: "A /\ exists x, C x"  CANNOT be decomposed using
  "[a b c]" because the constructor for the second argument 
  is not the same constructor as the one of the current term 
  being destructed.
  


============================================================
Rewrite-patterns

The general form of rewrite is:
  
     rewrite rpat1 ... rpatN
    
with the following rewriting patterns supported:

     term         attemps to rewrite with "term", 
                  TODO: we might add:
                  except if "term" has type "Prop", in which
                  case the rule below applies.
      
                  TODO: pb of interpretation of "rewrite E"  
                  for example when "E : a <-> (b = c)".
                  "E : a -> (b = c)".  not the same as "E : impl a (b = c)"

                  More generally, with setoids...
                  Is it fine to say that the outermost registered
                  setoid symbol should be considered?


     (term=term)  asserts that the equality is true and rewrites using it.
                  The equality becomes a side-condition.
                  TODO: should equality provable by reflexivity be
                  automatically discharged? or they would need "//"?
                  Remark: there is no ambiguity because "term=term"
                  is a term of type "Prop", so rewriting could not
                  TODO: is the syntax "(_:term=term)" too heavy? I think so.
                  => A PRIORI ca suffit de faire la syntaxe
                  => ARTHUR: voir le nombre d'exemple de assert_rewrite.
                  => ENRICO: comment faire: (_ : f ?x = ?x)
                     ENRICO: comment faire: (_ : f ?[x] = ?[x])
                  => GUILLAUME: replace (f ?x) with ?x.
                   
     -term        rewrite back

     &term        unfold term
                  (Note: we cannot use "/" because of conflict
                   with the general notation for tactic patterns)

     -&term       fold term

     !base        autorewrite with a base of lemmas,
                  repeat rewrite in a nonspecified order,
                  naively implemented as a tuple of lemmas
                  possibly optimized for efficiency reasons.
         
                  TODO: have an alternative matching mode,
                  for only matching syntaxically.

                     rewrite !base

                  Note: autorewrite does not use ssr rewrite matching.

     [tpat]rpat   is for selecting a term pattern in which the rewriting
                  will take place. See below for examples.
                  Note that outer matching subterms are considered first.
                  TODO: please remind me the logic of giving the target
                  before the rewriting lemma "rewrite E in H" vs "in H rewrite E".

     all intro pattern with a leading "/" can also be used here.


     {2}
     -[1 + 3]&(2 + 2).
     (erefl _ : 1 + 3 = 2 + 2)


Principle: Rewrite produces subgoals before the main goal.
  (Otherwise subgoals get stacked at the end.)

Principle: the main goal is tagged "main", and side goals are tagged 
  with names of the form "side_*". Side conditions can be selected
  using "/side:tac".

Example:
        rewrite E F. solveSideOfE. solveSideOfF.
  <->   rewrite E. solveSideOfE. rewrite F. solveSideOfF.

Example:
        rewrite E /(side: solveSideOfE) F /(side: solveSideOfF).
  <->   rewrite E /(side: solveSideOfE). rewrite F /(side: solveSideOfF).
  <->   rewrite E. solveSideOfE. rewrite F. solveSideOfF.


Sepcial case: in a rewrite chain, two symbols apply only to side goals by default:
  /-    kills side goals (all except main)
  //    attemps killing side goals (all except main)

Example:
   rewrite E /- F.            expects to kill all side conditions produced by E.
   rewrite E /(side: /-) F.   equivalent to the above.

Remark:
   When we want to kill the main goal using "/-", we can do one of:
     rewrite E; last by /-. "continue on side of E".
     rewrite E /(main:/-). "continue on side of E".
     rewrite E. main: /-. "continue on side of E".

LATER: the IDE could support executing until the middle point of a 
sequence of tokens. On "rewrite E <cursor> F", we would see the state
just after "rewrite E".





============================================================
Multipliers

For "rewrite" and "do" tactics

   n!     exactly n times

   n?     up to n times, possible less

   !      as many times as possible, at least once
          (think of it as "_!", i.e. with n not specified)
 
   ?      as many times as possible, possibly zero
          (think of it as "_?", i.e. with n not specified)



============================================================
Semantics of evar resolution.

Goal: give fine control on when instances (or other 
automatically-dischargeable goals) should be resolved.

Idea: define a tactic called "auto_discharge" which is
called at every ";" or "." in a *user* script, but not
at every ";" in a ltac script that is surrounded with
a "resolution_block" construct.

By default, to match the current behavior, "auto_discharge" 
calls "eauto using typeclasses" on goals whose head symbol 
is an instance of a typeclass. Variants can be interesting:
- only call typeclass resolution if all arguments (or at least 
  all the "important" arguments) are already fully resolved. 
- extend the mechanism to automatically attempt to discharge
  particular type of side-conditions, like "x \fresh_from E"
  in the context of metatheory proofs.

Consequence: in a user script (at top level),

     tac1. tac2.

  is in fact interpreted as:

     tac1; auto_discharge. tac2; auto_discharge.

Consequence: in a user script (at top level),

     tac1; tac2.

  is, similarly, interpreted as:

     tac1; auto_discharge; tac2; auto_discharge.

Principle: the programmer of a tactic can prevent the tactic
 "auto_discharge" to be called by entering a resolution block.
 In this case, the resolution will not be performed automatically.
 Instead, the user can do a manual call to "auto_discharge",
 with the effect of calling this tactic on all the evars (subgoals)
 that have been created within the scope of this block.


Example: 

     Ltac foo :=
       resolution_block (tac1; tac2).
  
   then "foo." calls "auto_discharge" only once, after "tac1" and "tac2".


Example:

   Ltac foo :=
     resolution_block (tac1; tac2; auto_discharge; tac3).

  allows calling "auto_discharge" explicitly on evars created by
  either "tac1" or "tac2".


Alternative syntax:   tac1;;tac2

   would be the same as        resolution_block (tac1; tac2).
   in the sense that ";;" does not auto_discharge,
   and that ";" is equivalent to ";;resolve;;".

   The difference is that ";;" may not have a nice nesting semantics.
   Or maybe it does? Consider ((tac1;;tac2);(tac3;;tac4)),
   in which auto_discharge is called at the ";" in the middle.



============================================================
Semantics of evar resolution, applied to "rewrite".


Semantics of "rewrite E" where E is a term, possibly with holes:
  (1) consider the term "E ?x ?y ?z" with as many evars
      as needed to make a setoid symbol appear at the head,
  (2) find an occurence where the left pattern matches,
  (3) perform the substitution, by building a proof term alongs
      the line of: [TODO: make more precise]
         refine (eq_ind .. (E ?x ?y ?z) .. ?goal:(..) ..)


Remark: the term E is interpreted just as any other constr,
  with holes completed with evars; these evars are not regeneralized,
  unless requested explicitly.

Observation:

     rewrite !(H _)

  is equivalent to:

     let E := constr:(H _) in
     rewrite !E


Observation:

     rewrite !(H _)

  is not equivalent to:

     repeat (rewrite (H _)).


Observation:

     rewrite !(constr_generalize:(H _))

  is [probably] equivalent to:

     repeat (rewrite (H _)).


Question: it may be surprizing that

     rewrite 2*(H _) 

   is not equivalent to

     rewrite (H _) (H _) 

   but I think this only reflects the ambiguity of the
   underscore notation, which lacks a precise binding point.



TODO: do we want to raise errors when some kind of evars
      are not resolved? not sure this is desirable/useful.


Example:

  E : forall x, P x -> f x x = g x.
  Goal : c (f 2 2).

  New goal: c (g 2)
  Subgoal: P 2.


Example:

  E: forall `{Inhab A}, forall (x:A), P x -> f x = inhab.
  Goal : c (f 2)

  New goal: c (inhab:nat)
  Subgoal: Inhab nat  ==> discharged by tactic "auto_discharge"
  Subgoal: P 2


Example:

  E : forall x y, P x y -> f x = g y.
  Goal : c (f 2).

  New goal: c (g ?y)
  Subgoal: P 2 ?y.


Example:
  
  E: forall `{Inhab A} `{Inhab B} (x:A) (y:B), @P A B x y -> f x = g y.
  Goal : c (f 2).

  New goal: c (g ?y)
  Subgoal: Inhab nat  ==> discharged by tactic "auto_discharge"
  Subgoal: Inhab ?B.  ==> should not be attempted before next subgoal solved (!)
  Subgoal: @P nat ?B 2 ?y.


Example:

  E : forall A, P A -> @f A x = x.
  Goal : c (f 2)
  
  New goal : c 2 
  Subgoal : P nat.
   

Example:

  E : forall A (x:A), P A -> @f A x = x.
  Goal : c (f 2) /\ d (f true).

  ==> rewrite !E

  New goal : c 2 /\ d true
  Subgoal : P nat
  Subgoal : P bool


Example:

  E : forall A, P A -> @f A x = x.
  Goal : c (f 2) /\ d (f true).

  ==> rewrite !(@E _)

  New goal : c 2 /\ d (f true)
  Subgoal : P nat.

  ==> because "E _" creates a single evar ?A, which is not
      regeneralized.

  ==> to obtain the same behavior as in the previous
      example, one can do: "rewrite !(constr_generalize:(@E _))





============================================================
Semantics of evar resolution, applied to "have".

- "have: E"    turns the goal G into T -> G, where T is the type of E.

- "have H: E"  adds an hypothesis H of type T, where T is the type of E.
               it is equivalent to "have:E => H".


Examples:

   assuming E : forall x y, P x -> P y.    (Implicit arguments [x])
   assuming F : P x.

   have H := (E _ F).                        => H: P ?y.
   have H := (@E _ _ F).                     => H: P ?y.
   have H := (#E F).                         => H: P ?y.

   have H := (@E x).                         => H: P x -> P ?y.
   have H := (#E x).                         => H: P x -> P ?y.
   have H := (@E x _ _).                     => H: P ?y.  With subgoal: P x.
   have H := (#E x __).                      => H: P ?y.  With subgoal: P x.

   have H := constr_generalize:(@E x).       => H: forall y, P x -> P y.
   have H := constr_generalize:(@E _ _ F).   => H: forall y, P y.
   have H := constr_generalize:(#E F).       => H: forall y, P y.

TODO: need to find better symbol for "constr_generalize".



Example:
   assume E : forall `{Group G} (x y:G), op G x y = neutral G -> x = inv G y.
   assume a : A.

   have H := (#E a).   
     => will produce:
        H : forall (x:A), op A x a = neutral A -> a = inv A y.
        suboal: Group A. => will be subject to "auto_discharge".

   have H := (#E __ a).  
   have H := (@E _ _ _ a).       ---same
     => will produce: 
        H : op A ?x a = neutral A -> ?x = inv A a.
        suboal: Group A. => will be subject to "auto_discharge".
 
   have H := constr_generalize:(#E a).   
     => will produce:
        H : Group A -> forall (y:A), op A a y = neutral A -> a = inv A y.
     => because "Group A" was not solved, it has been requantified.
     => but maybe we wanted it as a subgoal! how can we get this?

   have H := ltac:(let M := constr:(#E a) in auto_discharge; constr:(M)).   
     => will produce, assuming "Group A" to be solvable:
        H : forall (y:A), op A a y = neutral A -> a = inv A y.
     => way too heavy! TODO

   have H := constr_generalize:(#E __ a).   
     => will produce:
        H : Group A -> forall (x:A), op A x a = neutral A -> x = inv A a.
     => because "Group A" was not solved, it has been requantified.
     => but maybe we wanted it solved! how can we get this? TODO


Example:
   assume E : forall `{Inhab A} `{Inhab B} (x:A) (y:b), P x y -> Q x y.

   have H := (#E 3).
   => will produce
      H : forall (y:?B), P 3 y -> Q 3 y.
      Subgoal : Inhab nat.  => will be subject to "auto_discharge".
      Subgoal : Inhab ?B.   => problematic if solved by "auto_discharge"... TODO

   have H := constr_generalize:(#E 3).
   => will produce
      H : Inhab nat -> forall `{Inhab B} (y:B), P 3 y -> Q 3 y.
   => because Inhab nat has not been yet solved.
   => but maybe we wanted it solved! how can we get this? TODO



============================================================
Semantics of "assert"

- "assert H: E"  is equivalent to "assert E; [|=> H]".
- "assert E" on a goal G produces two subgoals:
     E  and  E -> G 




============================================================
Specifying subterms for rewriting and other operations.
     

TODO: update/complete/polish/discuss.

(i'm only trying to guess here)
Target subterms for rewriting: 

   rewrite [foo _ _]E
   => rewrites E inside subterms of the form "foo _ _"

   rewrite [x in foo x _]E
   => rewrites E inside the x in subterms of the form "foo x _"

   TODO: comprendre quel est le besoin ici; et le cas général
   de sélection de sous-terme avec patterns imbriqués (aussi utile 
   pour d'autres tactiques).
   rewrite [bar _ inside (foo _ _)]E
   => rewrites E inside x inside subterms of the form "foo _ _"


   TODO: how to do "rewrite E in H" in ssr? 
   Is: "on H rewrite E" doing "protect; move: H; rewrite E; intro; unprotect".
   Could we make it so that the hypothesis goes back to its original place?




============================================================
Killing false subgoals


   false_goal        replace the goal by "False".

   false             call "false_goal", then try to kill the goal
                     using one of: 
                     - assumption
                     - equal        (new name for "congruence")
                     - inject       (subsumes "discriminate")
                     - cyclic       (proving, e.g. "x <> S x")

   false E          shorthand for "false_goal; apply E".

 

============================================================
Cycles in inductives

   cyclic x         proves a contradiction by exploiting
                    a cycle starting from variable x and
                    going through inductive constructors,
                    e.g. "x = S y /\ y = S x".

   cyclic           equivalent to "try solve [cyclic x]" for every 
                    variable "x" in the goal, but actually more
                    efficient, since a O(n) DFS is possible.

   H:
        P n (S n)
        P (S x) x


============================================================
Inject


   inject_once      takes the head hyp "C x1 x2 = C y1 y2"
   []               and replaces it with "x1 = y1" and "x2 = y2".
                    
                    TODO: if the constructor involves dependent types,
                    then it produces "sigma x1 x2 = sigma y1 y2". or not?

   inject           repeats "inject_once" recursively.
   [H1 [H2 H3]]     "C x1 (D x2 x3) = C y1 (D y2 y3)"
   /inject[^ prefix_ ].   TODO              

   inject: H        shorthand for moving H in the goal first

   inject pat: H    shorthand for moving H in the goal first


TODO: what names to give to tactics that immediately substitute
      the equalities that they produce. "injects" would do this?
      useful for dependent constructors, since there is no other way?


LATER: (is it useful?)
   inject pat       specify a pattern that inject should follow, in order
                    to control the depth. e.g. on 
                    "C x1 (D x2 (E x3)) = C y1 (D y2 (E y3))"
                    we can call "inject [_ [_ _]]" to produce
                    x1 = y1 and x2 = y2 and E x3 = E y3.


============================================================
Invert


   invert         takes the head hyp and performs:  
                  - case analysis, with remembered equalities
                  - calls inject on equalities produced (includes discriminate)
                  - possibly, try to kill goals using tactic "cyclic" 
                  - perform substitutions of fresh variables that
                    are involved in a single equality.

  invert_nosubst  same but does not attempt to perform any substitution

  invert: H       shorthand for moving H down before "invert".                    



General pattern:

  Cstr : forall n1 n2, P f1 f2            f1 and f2 use n1 and n2
  Goal : forall (H: P e1 e2), G H
  Res  : forall n1 n2, (sigma f1 f2 = sigma e1 e2) -> forall (H: P e1 e2) -> G H

Simplified case when the hypothesis is not dependently used:
 
  P : forall x, R x -> T
  Cstr : forall n1 n2, P f1 f2
  Goal : P e1 e2 -> G
  Res  : forall n1 n2, (sigma f1 f2 = sigma e1 e2) -> G

Further simplification P is not dependent,
then sigma is just a tuple operator and injection gives:

  Res  : forall n1 n2, f1 = e1 -> f2 = e2 -> G     ("truc de base")

  already does more than inversion because it adds equalities
  

  inversion does more injection than this.
   S a = S b 
   a = b


=> examples where the default invert does not work well
   because of loss of sharing


Example 0: problematic subsitution of a fresh variable

  Cstr : forall n, A n -> B n -> P n
  Goal : P x -> G
  ResN : forall n, n = x -> A n -> B n -> G
  "obviously good to substitute x instead of fresh n"
  Res  : A x -> B x -> G


Example 1: problematic subsitution of a fresh variable

  Cstr : forall n, A n -> B n -> P n
  Goal : P (big x) -> G
  ResN : forall n, n = big x -> A n -> B n -> G
  Res  : A (big x) -> B (big x) -> G
  

  Res' : let n := big x in A n -> B n -> G



Example 2: problematic subsitution of an existing variable

  Cstr : forall n, P (big n)
  Goal : P x -> A x -> B x -> G
  Res  : forall n, A (big n) -> B (big n) -> G
   => could not work if x occurs elsewhere
   => is it ever desirable to substitute x in existing hypotheses


Example 3: combination of 1 and 2

  Cstr : forall n m, A n -> B n -> P n (big m)
  Goal : P (big x) y -> C y -> D y -> G
  Res  : forall m, A (big x) -> B (big x) -> C (big m) -> D (big m) -> G


Example 4: constructors involving explicit equalities

  Cstr : forall n m, m = big n -> P m
  Goal : P x -> A x -> B x -> G
  Res  : forall n, m = big n -> A m -> B m -> G

  => invert should not remove the equality


Example 5: no canonical choice for which equality to substitute

  Cstr : forall n, A n -> B n -> P n n
  Goal : P (f x) (g y) -> G
  Res  : forall n, n = f x -> n = g y -> A n -> B n -> G

    A (f x)
    A (g y)



Remark: 

  Cstr : forall n, let m := big n in P m m
  => lack of control here.








============================================================
Tag mechanism on goals -- Postponed to LATER.

  - tactics attach tags to goals they produce

  - e.g. invert attaches the constructor corresponding name to the case

  - tags are actually list of names, useful e.g. for "invert H1; invert H2".

  - a tactic, call it "goal" or "case", can be used to select one of
    the remaining by a regexp-like on the tag (expects no ambiguity).
  
  - e.g.  "^beta" selects the case coming from constructor "red_expr_beta".
 
Proposal for being able to name branches in branching intropatterns:

    [S: n | O: ]    same as [|n], but robust to order of branches.

 alternative syntax:  [S=> n | O=>] 



============================================================
General clear mechanism


   {x}    denotes the term "x", with the interpretation that
          the variable "x" will be cleared at the end of the
          tactic execution (i.e. at next semi-column).

Examples:  
  - apply {H} x.
  - rewrite H1 {H2}.
  - apply (foo {H}).





============================================================
Discussion on intropatterns.

Can we get away without fast mode, using only ">" to mean
"intro all dependent variables"? Short answer is: yes.

I would write "=>>" wherever I currently write "introv". 
In a few cases, I would need an additional ">" in the list 
of intropatterns. It turns out that there are only a limited number 
of places where I need this throughout TLC. 
I classified these situations that I encountered.


*) Situation 1: unfolding definitions starting with a forall.

Current script: 

   Definition foreach P E :=
      forall x, x \in E -> P x.

   Lemma foreach_weaken : forall P Q E,
     foreach P E -> pred_le P Q -> foreach Q E.
   Proof using. introv H L K. Abort.
   (* Here, K has type "x \in E" *)

Proposed replacement:

   Proof using. =>> H L > K. Abort. 

Remark: this assumes that ">" will call "hnf" if there is
no visible quantifier at all. Otherwise, I'd need to call
/hnf to unfold the head symbol, and write:

   Proof using. =>> H L /hnf > K. Abort. 

Conclusion: the second possibility is a bit heavy, I think
it is fine to assume that ">" will do an unfolding if there
is nothing to introduce.


*) Situation 2: proving elimination lemmas.

Current script:

   Lemma irrefl_neq : forall R,
     irrefl R -> 
     forall x y, R x y -> x <> y. 
   Proof using. introv > H P E. Abort.

Proposed replacement:

   Proof using. =>> H > P E. Abort. 

Conclusion: fair enough to write the extra ">".


*) Situation 3: proving induction principles (similar to above).

   Definition eq_ind_r : forall (P:A -> Prop), 
     P x -> forall y, y = x -> P y.
   Proof using. introv Px H. Abort.

Proposed replacement:

   Proof using. =>> Px > H. Abort. 

Conclusion: fair enough. 


*) Situation 4: lemmas requiring a type to be inhabited 
   even though the statement itself does not use the instance.

   Theorem rec_fixed_point : forall A B {IB:Inhab B} 
    (F:(A->B)->(A->B)) (R:binary A) (P:A->Prop) (S:A->B->Prop) (E:binary B), 
     equiv E -> (forall x, pred_compatible E (S x)) ->
     wf R -> rec_contractive E P F R S ->
     exists (f:A->B), partial_fixed_point E F (Build_partial f P)
                  /\ (forall x, P x -> S x (f x)).
   Proof using. introv IB Equiv Comp WfR Cont. Abort.

Proposed replacement:

   Proof using. =>> IB > Equiv Comp WfR Cont. Abort.

Arthur wants:
   Proof using. =>> Equiv Comp WfR Cont. Abort.


Conclusion: it is a bit unfortunate that I need an extra > here.
One could argue that "Inhab B", if it not dependently used, 
should appear later in the list of hypothesis. But, morally,
I want "an inhabited type B", so I like to have "Inhab B"
to place immediately next to "B".
(Troll: IMO, types should be inhabited by default, like in HOL ;)



TODO: validate the proposal below.

I could live with the additional ">", sure, but it does not look nice.
One possibility would be to do a special case to say that hypotheses 
of the form "Inhab B" are treated as if there were dependently-used
variables. Maybe this would generalize to other typeclasses?
In this case, maybe we can have a command for registering 
patterns of hypotheses that should be considered by ">".
In fact, I would be happy to have just for myself an overloaded
definition of the "plus" tactic. By this I mean that if the
implementation of "=> ipat" when "ipat" is ">" is to call
a tactic "intro_pattern_plus", and that I am able to bind my
own tactic there, I would do:
 

ARTHUR NETTOIE:

   Ltac intro_pattern_plus :=
      match goal with
      | _ -> _ => idtac
      | ?E -> _ => check_typeclass_instance E; intro ?; intro_pattern_plus 
      | forall _, _ => intro ?; intro_pattern_plus 
      | _ => hnf; (... same process if a forall a is made visible ...)

   Pseudo Ltac intro_nondeps already_hnf :=
     match goal with
     |- (_ -> _)                       => idtac
     |- (forall _,_)                   => intro ?; intro_nondeps true
     |- _             when already_hnf => idtac
     |- _                              => hnf; intro_nondeps true

   + special case for Arthur:
      | Inhab _ -> _ => intro ?; intro_nondeps true 



============================================================
Need to optimize autorewrite

Autorewrite needs primitive support, and needs cheap syntactic matching
that does not trigger computations.


   Hint Rewrite app_cons app_nil_l app_nil_r app_assoc 
    app_cons_one 
    fold_right_nil fold_right_cons fold_right_app
    fold_right_last 
    fold_left_nil fold_left_cons fold_left_app
    fold_left_last 
    length_nil length_cons length_app length_rev
    length_last 
    rev_nil rev_app rev_cons rev_last rev_rev
    concat_nil concat_app concat_cons concat_last 
     map_nil map_cons map_app map_last 
    mem_nil mem_cons mem_app mem_last 
    mem_cons_eq mem_last_eq 
    keys_nil keys_cons keys_app keys_last
    assoc_cons assoc_here 
    .... : rew_list.

where e.g.:

   Lemma filter_nil : 
     filter f nil = nil.
   Lemma filter_cons : forall x l,
     filter f (x::l) = if f x then x :: filter f l else filter f l.
   Lemma filter_app : forall l1 l2,
     filter f (l1 ++ l2) = filter f l1 ++ filter f l2.
   Lemma filter_last : forall x l,
     filter f (l & x) = filter f l ++ (if f x then x::nil else nil).



 
============================================================
Other use cases of generalize_constr


  /view_term
   => regeneralize (view_term _top_)



   leq_trans : forall y x, x < y -> (forall z, y < z -> x < z)
   leq_trans' : forall y x z, x < y -> y < z -> x < z

   =====
   a < b -> G

   move=> ..  /(leq_trans 4)

   _top_ : a < b
   ====
   G

   leq_trans ?x ?y ?z _top_ : b < ?z -> a < ?z

   (b < ?z -> a < ?z) -> G

   (forall z, b < z -> a < z) -> G

   
Alternative:

   leq_equiv : forall x y z, R x y <-> (R x z /\ R z y)

   "View"
      forall x y, R x y -> forall z, (R x z /\ R z y)
      forall x y z, (R x z /\ R z y) -> R x y.

     Ltac "leq_equiv" := 
     Ltac "-leq_equiv" :=


   


============================================================
TODO: other tactics needed in general.




============================================================
TODO: optimization of invert





========================================================================
TODO: Logic operations on goals

[conj]
  Applies to a n-ary conjunction, and splits it into subgoals.
  If the head of the goal is not a conjunction, then hnf is called;
  if the goal is still not a conjunction, then an error is raised.
  If n-ary conjunctions are encoded using a single predicate, then it
  is equivalent to a single call to "constructor".
  If n-ary conjunctions are encoded using binary conjunction, then the
  arity depends on the number of conjunction visible in the goal.
  -- Remark: we could call this tactic "split", but for uniformity with
  all other tactics in this section, it should be called "conj".

[disj i]
  Applies to a n-ary disjunction, and enters the i-th branch 
  (counting from 1).
  If the head of the goal is not a disjunction, then hnf is called;
  if the goal is still not a conjunction, then an error is raised.
  -- Optional: "left"/"right" could be an alias for "disj 1"/"disj 2".

[exists v _ w]
  Applies to an existential goal, and provides witnesses.
  If the goal does not exhibit sufficiently many "exists", 
  hnf is called; if not revealing a existential, an error is raised.
  Underscore are accepted, they stand for fresh evars.
  If is fine to provide fewer witnesses than the number of visible
  existentials.

[iff]
  Applies to a goal of the form "P <-> Q", it leaves two subgoals
  "P -> Q" and "Q -> P".
  If the goal is of the form "forall ..., P <-> Q", then it leaves 
  two subgoals subgoals:  "forall ..., P -> Q" and "forall ..., Q -> P".
  If the goal is not of any of these forms, then unfolding is performed
  until exhibiting a "<->". An error is raised otherwise.

  -- Example usage: "iff => [M1|(M2 M3)]"  on "P <-> (Q /\ R)".
 
  The behavior of [iff] can be extended by libraries/users in order
  to make it applicable to apply extensionality, e.g.:
  - "forall ..., P = Q :> Prop"   (assuming predicate extensionality)
  - "forall ..., b = b' :> bool"  (producing b -> b' and b' -> b)
  - "forall ..., E = F :> set A"  (producing "forall x, x \in E -> x \in F", and reciprocal)

[true] 
  Applies to a goal of the form "True", and discharges it.
  Also applies to a goal of the form "forall ..., True".
  If the goal cannot be put in this form, the tactic fails.
  The behavior can be extended by libraries or by the user 
  to prove other goals that can be proved true without 
  producing any further subgoals.
  Remark: we need to introduce a variant of the "hint" mechanism 
  that binds tactics as "extern hints" for specific tactics.

[false]  -- UPDATE: see specific section about "false" above.
  Applies to any goal. It replaces the goal with "False".
  The tactic can be extended by libraries or by the user
  to prove contradictions. By default, the tactic executes
     try solve [ assumption | discriminate | congruence ].
   [false E]
   Applies to any goal. It replaces the goal with "False",
   and applies lemma E to the goal.

[absurd]
  Tactic specific to classical logic ("the goal would be absurd").
  Applies to any goal "G", and replaces it with "~ G -> False". 
  Typical usage is "absurd => M."

[absurd E]
  Tactics applies to any goal, and replaces it with "~ T",
  where T is the type of expression E.
  Typical usage: "absurd {H}", where "H" is an hypothesis.
  It the goal becomes of the form "C ... <> C' ...", where
  C and C' are distinct constructors, the goal is automatically
  discharged.



========================================================================
Logical cuts -- TODO: polish first before discussion

[prove T]
[prove I: T]   
   -- Remark: "prove" is a new name instead of "assert" or "have" whose intent is 
      less obvious than "clear", imo.
   "prove T" applies to any goal G. It produces a subgoal T, and a subgoal T->G.
   "prove I: T" is a shorthand for "prove T; [|=>I]".

   Here, T is provided in open syntax, meaning that parentheses are not needed.
   E.g.:  prove I: forall (x y : unit), x = y.


[suffice T] // optional
[suffice I: T] 
   "suffice T"    is a shorthand for "prove T; swap 1 2".
   "suffice I: T" is a shorthand for "prove I: T; swap 1 2".
   where "swap 1 2" swaps the two subgoals generated.


========================================================================
Application

[exact H] 
   equivalent to current [refine]. TODO: specify more precisely.

[apply H] 
   Applies the hypothesis H to the goal. 
   
   --TODO: What is the specification? 
     is there a better way than saying that it tries to apply
     "refine (H _ _ _)"  for increasing numbers of underscores?
     
   Here, the term "H" can be provided in open syntax, meaning that 
   parentheses are not needed. In particular,
   "apply H x y z"  is a shorthand for "apply (H x y z)"
   "apply $H x y z" is a shorthand for "apply ($H x y z)"

   Remark: "apply {H}" applies hypothesis H then clears it.

[constr] 
  Applies to a goal "P EX1 .. EN" where P is inductively-defined.
  Applies the only constructor of this inductive data type for which
  the invokation of the tactic "apply E" succeeds.

  ---Optional (not recommended imo): specification of [constr] for builtin types:
  - "constr" on a n-ary conjunction is the same as "conj".
  - "constr" on an equivalence is the same as "iff".
  - "constr" on an existential is the same as "exists _".

  ---Technical remark: implemented as "exactly_once econstructor", 
  that is, like "econstructor", but fails if more than one constructor 
  could be applied.


========================================================================
Equality and rewriting

[rewrite p]   
   See specific section.
      
[subst x]
  Substitute away the equality for "x".
  If there are attemps of recursive substitution, substitute everywhere
  where possible, and keep the hypothesis involving the equality on x.

[equal]
  Invokes the congruence tactic, which may solve the goal.
  Otherwise, if the goal of the form [f a b = f' a' b'],
  then it calls "fequal", and try "congruence" on every subgoal.
  This tactic never fails; if it can't make progress it does nothing.
  --> TODO: I am not sure this is the desired behavior; often, it is
      much better to have tactic fail when they do not progress;
      we could give this alternative spec. Opinion?

  -- Suggested implementation: equivalent to "try fequal; congruence"?

  -- Remark: this covers [reflexivity], [fequal] and [congruence].

  ==> TODO: what is the connection with "congr" from ssr?




========================================================================
Induction

--> Naming: I think "induct" says as much as "induction", and "invert" as much
    as "inversion". After all, we have a tactic called "apply" and it
    is not called "application", for a good reason imo...

[induct H]
  Like Coq induction, but 
  - saves the arguments that are not variables, by introducing equalities
  - produces all hypotheses in the goal, including induction principles

[induct_wf: R E]
  Helper for performing induction on a well-founded relation R.
  The expression E is the argument in the goal which is to be proved
  accessible w.r.t. the well-founded relation R.
  -- Implementation: "set (X:=E); pattern X; apply (well_founded_ind E); clear X".

[induct_wf X IH: R] // only useful to advanced users 
   Shorthand for "induction_wf: R X => IH X".




========================================================================
Goal management tactics

[admit]
  Skips the current goal.
  -- Implemented by creating an evar that is in a special shelf,
     the shelf of admitted subgoals.


========================================================================
OTHER:
** goal reordering
  --> like in ssr? what about Coq's new features? TODO!

** variable renaming
  --> do we want to keep the syntax [rename x1 into y1, x2 into y2]
  --> Note that renaming for hypotheses works with "move: H1 H2 => M1 M2",
      but this can't be done so easily for variables in a neat way.
  

========================================================================
For advanced users only

[tryfalse]
  useful shorthand for "try solve [false]".

[exists_all]
  equivalent to [exists _ _ _] with as many existentials as visible in the goal.

[unfold] (without any argument)
  unfolds the head symbol of the first hypothesis in the goal;
  or the head symbol of the conclusion if there is no hypothesis,
  or the head symbol of the first argument if the goal is an equality.

[unfold in H]
   same as above, but for an hypothesis.

[case_if] / [case_match]
  performs case analysis on the first if/match in the goal

[flexible p]
   where p is a pattern: replaces the occurences of "p" with fresh evars.
   For example on the goal "P (3*x) y", the tactic "flex (_*_)" will give
   the goal "P ?a y" and subgoal "?a = 3*x".

   If the equality subgoal can be proved by proof irrelevance and the
   proof irrelevance axiom is available, then this goal is discharged.
   Equivalent to TLC "equates", and allows to do TLC's "applys_eq",
   and also TLC's "pi_rewrite".

[equal_rec]
  shorthand for [repeat (progress equal)], useful to prove in depth
  equalities, e.g. in a goal  "f (g x y) z = f (g x' y) z".


========================================================================
Questions:

==> how to do TLC's "sets_eq" tactic.
   move En: (size l) => n.
==> this does not seem very regular...