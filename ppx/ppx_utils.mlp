(************************************************************************)
(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
(* <O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2016     *)
(*   \VV/  **************************************************************)
(*    //   *      This file is distributed under the terms of the       *)
(*         *       GNU Lesser General Public License Version 2.1        *)
(************************************************************************)

(* This file defines standard combinators to build ml expressions *)

type argument_type =
| ListArgType of argument_type
| OptArgType of argument_type
| PairArgType of argument_type * argument_type
| ExtraArgType of string

type user_symbol =
| Ulist1 of user_symbol
| Ulist1sep of user_symbol * string
| Ulist0 of user_symbol
| Ulist0sep of user_symbol * string
| Uopt of user_symbol
| Uentry of string
| Uentryl of string * int

type extend_token =
| ExtTerminal of string
| ExtNonTerminal of user_symbol * string

let mlexpr_of_list f l =
  let fold e accu = [%expr [%e (f e) ] :: [%e accu ] ] in
  List.fold_right fold l [%expr [] ]

let mlexpr_of_pair m1 m2 (a1, a2) =
  let e1 = m1 a1 and e2 = m2 a2 in
  [%expr ([%e e1], [%e e2]) ]

let mlexpr_of_bool = function
| true -> [%expr true ]
| false -> [%expr false ]

let mlexpr_of_int n = Ast_convenience.int n

let mlexpr_of_string s = Ast_convenience.str s

let mlexpr_of_option f = function
| None -> [%expr None]
| Some e -> [%expr (Some [%e (f e) ]) ]

let symbol_of_string s =
  let s = mlexpr_of_string s in
  [%expr (Extend.Atoken (CLexer.terminal [%e s ])) ]

let rec mlexpr_of_prod_entry_key f = function
| Ulist1 s ->
  let s = mlexpr_of_prod_entry_key f s in
  [%expr (Extend.Alist1 [%e s ]) ]
| Ulist1sep (s,sep) ->
  let s = mlexpr_of_prod_entry_key f s in
  let sep = symbol_of_string sep in
  [%expr Extend.Alist1sep ([%e s ], [%e sep ]) ]
| Ulist0 s ->
  let s = mlexpr_of_prod_entry_key f s in
  [%expr (Extend.Alist0 [%e s ]) ]
| Ulist0sep (s,sep) ->
  let s = mlexpr_of_prod_entry_key f s in
  let sep = symbol_of_string sep in
  [%expr Extend.Alist0sep ([%e s ], [%e sep ]) ]
| Uopt s ->
  let s = mlexpr_of_prod_entry_key f s in
  [%expr (Extend.Aopt [%e s ]) ]
| Uentry e ->
  let s = f e in
  [%expr (Extend.Aentry [%e s ]) ]
| Uentryl (e, l) ->
  (** Keep in sync with Pcoq! *)
  assert (e = "tactic");
  if l = 5 then [%expr Extend.Aentry (Pcoq.Tactic.binder_tactic) ]
  else
    let i = mlexpr_of_int l in
    [%expr Extend.Aentryl (Pcoq.Tactic.tactic_expr, [%e i ]) ]

let rec type_of_user_symbol = function
| Ulist1 s | Ulist1sep (s, _) | Ulist0 s | Ulist0sep (s, _) ->
  ListArgType (type_of_user_symbol s)
| Uopt s ->
  OptArgType (type_of_user_symbol s)
| Uentry e | Uentryl (e, _) -> ExtraArgType e

let mk_extraarg s = Ast_convenience.evar ("wit_" ^ s)

let rec make_wit = function
| ListArgType t -> [%expr Genarg.wit_list [%e make_wit t ] ]
| OptArgType t -> [%expr Genarg.wit_opt [%e make_wit t ] ]
| PairArgType (t1,t2) ->
    [%expr Genarg.wit_pair [%e make_wit t1 ] [%e make_wit t2 ] ]
| ExtraArgType s -> mk_extraarg s

let make_topwit arg = [%expr Genarg.topwit [%e make_wit arg ] ]

let coincide s pat off =
  let len = String.length pat in
  let break = ref true in
  let i = ref 0 in
  while !break && !i < len do
    let c = Char.code s.[off + !i] in
    let d = Char.code pat.[!i] in
    break := c = d;
    incr i
  done;
  !break

let rec parse_user_entry s sep =
  let l = String.length s in
  if l > 8 && coincide s "ne_" 0 && coincide s "_list" (l - 5) then
    let entry = parse_user_entry (String.sub s 3 (l-8)) "" in
    Ulist1 entry
  else if l > 12 && coincide s "ne_" 0 &&
                   coincide s "_list_sep" (l-9) then
    let entry = parse_user_entry (String.sub s 3 (l-12)) "" in
    Ulist1sep (entry, sep)
  else if l > 5 && coincide s "_list" (l-5) then
    let entry = parse_user_entry (String.sub s 0 (l-5)) "" in
    Ulist0 entry
  else if l > 9 && coincide s "_list_sep" (l-9) then
    let entry = parse_user_entry (String.sub s 0 (l-9)) "" in
    Ulist0sep (entry, sep)
  else if l > 4 && coincide s "_opt" (l-4) then
    let entry = parse_user_entry (String.sub s 0 (l-4)) "" in
    Uopt entry
  else if l = 7 && coincide s "tactic" 0 && '5' >= s.[6] && s.[6] >= '0' then
    let n = Char.code s.[6] - 48 in
    Uentryl ("tactic", n)
  else
    let s = match s with "hyp" -> "var" | _ -> s in
    Uentry s
